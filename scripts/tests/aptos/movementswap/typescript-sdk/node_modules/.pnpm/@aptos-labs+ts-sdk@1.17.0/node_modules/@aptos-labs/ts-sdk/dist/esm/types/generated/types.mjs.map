{"version":3,"sources":["../../../../src/types/generated/types.ts"],"sourcesContent":["export type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends \" $fragmentName\" | \"__typename\" ? T[P] : never };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string };\n  String: { input: string; output: string };\n  Boolean: { input: boolean; output: boolean };\n  Int: { input: number; output: number };\n  Float: { input: number; output: number };\n  bigint: { input: any; output: any };\n  jsonb: { input: any; output: any };\n  numeric: { input: any; output: any };\n  timestamp: { input: any; output: any };\n  timestamptz: { input: any; output: any };\n};\n\n/** Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'. */\nexport type BooleanComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"Boolean\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"Boolean\"][\"input\"]>>;\n};\n\n/** Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'. */\nexport type IntComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"Int\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"Int\"][\"input\"]>>;\n};\n\n/** Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'. */\nexport type StringComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column match the given case-insensitive pattern */\n  _ilike?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  /** does the column match the given POSIX regular expression, case insensitive */\n  _iregex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  /** does the column match the given pattern */\n  _like?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given case-insensitive pattern */\n  _nilike?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  /** does the column NOT match the given POSIX regular expression, case insensitive */\n  _niregex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given pattern */\n  _nlike?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given POSIX regular expression, case sensitive */\n  _nregex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given SQL regular expression */\n  _nsimilar?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column match the given POSIX regular expression, case sensitive */\n  _regex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column match the given SQL regular expression */\n  _similar?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactions = {\n  account_address: Scalars[\"String\"][\"output\"];\n  /** An array relationship */\n  coin_activities: Array<CoinActivities>;\n  /** An aggregate relationship */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** An array relationship */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** An array relationship */\n  fungible_asset_activities: Array<FungibleAssetActivities>;\n  /** An array relationship */\n  token_activities: Array<TokenActivities>;\n  /** An aggregate relationship */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** An array relationship */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** An aggregate relationship */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  /** An object relationship */\n  user_transaction?: Maybe<UserTransactions>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsFungibleAssetActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** aggregated selection of \"account_transactions\" */\nexport type AccountTransactionsAggregate = {\n  aggregate?: Maybe<AccountTransactionsAggregateFields>;\n  nodes: Array<AccountTransactions>;\n};\n\n/** aggregate fields of \"account_transactions\" */\nexport type AccountTransactionsAggregateFields = {\n  avg?: Maybe<AccountTransactionsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AccountTransactionsMaxFields>;\n  min?: Maybe<AccountTransactionsMinFields>;\n  stddev?: Maybe<AccountTransactionsStddevFields>;\n  stddev_pop?: Maybe<AccountTransactionsStddevPopFields>;\n  stddev_samp?: Maybe<AccountTransactionsStddevSampFields>;\n  sum?: Maybe<AccountTransactionsSumFields>;\n  var_pop?: Maybe<AccountTransactionsVarPopFields>;\n  var_samp?: Maybe<AccountTransactionsVarSampFields>;\n  variance?: Maybe<AccountTransactionsVarianceFields>;\n};\n\n/** aggregate fields of \"account_transactions\" */\nexport type AccountTransactionsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AccountTransactionsAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"account_transactions\". All fields are combined with a logical 'AND'. */\nexport type AccountTransactionsBoolExp = {\n  _and?: InputMaybe<Array<AccountTransactionsBoolExp>>;\n  _not?: InputMaybe<AccountTransactionsBoolExp>;\n  _or?: InputMaybe<Array<AccountTransactionsBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  coin_activities?: InputMaybe<CoinActivitiesBoolExp>;\n  coin_activities_aggregate?: InputMaybe<CoinActivitiesAggregateBoolExp>;\n  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  token_activities?: InputMaybe<TokenActivitiesBoolExp>;\n  token_activities_aggregate?: InputMaybe<TokenActivitiesAggregateBoolExp>;\n  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  user_transaction?: InputMaybe<UserTransactionsBoolExp>;\n};\n\n/** aggregate max on columns */\nexport type AccountTransactionsMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AccountTransactionsMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"account_transactions\". */\nexport type AccountTransactionsOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  coin_activities_aggregate?: InputMaybe<CoinActivitiesAggregateOrderBy>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;\n  fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateOrderBy>;\n  token_activities_aggregate?: InputMaybe<TokenActivitiesAggregateOrderBy>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  user_transaction?: InputMaybe<UserTransactionsOrderBy>;\n};\n\n/** select columns of table \"account_transactions\" */\nexport enum AccountTransactionsSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type AccountTransactionsStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AccountTransactionsStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AccountTransactionsStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"account_transactions\" */\nexport type AccountTransactionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AccountTransactionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AccountTransactionsStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AccountTransactionsSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AccountTransactionsVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AccountTransactionsVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AccountTransactionsVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_events_summary\" */\nexport type AddressEventsSummary = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  block_metadata?: Maybe<BlockMetadataTransactions>;\n  min_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"address_events_summary\". All fields are combined with a logical 'AND'. */\nexport type AddressEventsSummaryBoolExp = {\n  _and?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;\n  _not?: InputMaybe<AddressEventsSummaryBoolExp>;\n  _or?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  block_metadata?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n  min_block_height?: InputMaybe<BigintComparisonExp>;\n  num_distinct_versions?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"address_events_summary\". */\nexport type AddressEventsSummaryOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  block_metadata?: InputMaybe<BlockMetadataTransactionsOrderBy>;\n  min_block_height?: InputMaybe<OrderBy>;\n  num_distinct_versions?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"address_events_summary\" */\nexport enum AddressEventsSummarySelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  MinBlockHeight = \"min_block_height\",\n  /** column name */\n  NumDistinctVersions = \"num_distinct_versions\",\n}\n\n/** Streaming cursor of the table \"address_events_summary\" */\nexport type AddressEventsSummaryStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AddressEventsSummaryStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AddressEventsSummaryStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  min_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  num_distinct_versions?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEvents = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An array relationship */\n  coin_activities: Array<CoinActivities>;\n  /** An aggregate relationship */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** An array relationship */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** An array relationship */\n  token_activities: Array<TokenActivities>;\n  /** An aggregate relationship */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** An array relationship */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** An aggregate relationship */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** aggregated selection of \"address_version_from_events\" */\nexport type AddressVersionFromEventsAggregate = {\n  aggregate?: Maybe<AddressVersionFromEventsAggregateFields>;\n  nodes: Array<AddressVersionFromEvents>;\n};\n\n/** aggregate fields of \"address_version_from_events\" */\nexport type AddressVersionFromEventsAggregateFields = {\n  avg?: Maybe<AddressVersionFromEventsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AddressVersionFromEventsMaxFields>;\n  min?: Maybe<AddressVersionFromEventsMinFields>;\n  stddev?: Maybe<AddressVersionFromEventsStddevFields>;\n  stddev_pop?: Maybe<AddressVersionFromEventsStddevPopFields>;\n  stddev_samp?: Maybe<AddressVersionFromEventsStddevSampFields>;\n  sum?: Maybe<AddressVersionFromEventsSumFields>;\n  var_pop?: Maybe<AddressVersionFromEventsVarPopFields>;\n  var_samp?: Maybe<AddressVersionFromEventsVarSampFields>;\n  variance?: Maybe<AddressVersionFromEventsVarianceFields>;\n};\n\n/** aggregate fields of \"address_version_from_events\" */\nexport type AddressVersionFromEventsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AddressVersionFromEventsAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"address_version_from_events\". All fields are combined with a logical 'AND'. */\nexport type AddressVersionFromEventsBoolExp = {\n  _and?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;\n  _not?: InputMaybe<AddressVersionFromEventsBoolExp>;\n  _or?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  coin_activities?: InputMaybe<CoinActivitiesBoolExp>;\n  coin_activities_aggregate?: InputMaybe<CoinActivitiesAggregateBoolExp>;\n  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  token_activities?: InputMaybe<TokenActivitiesBoolExp>;\n  token_activities_aggregate?: InputMaybe<TokenActivitiesAggregateBoolExp>;\n  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AddressVersionFromEventsMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AddressVersionFromEventsMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"address_version_from_events\". */\nexport type AddressVersionFromEventsOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  coin_activities_aggregate?: InputMaybe<CoinActivitiesAggregateOrderBy>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;\n  token_activities_aggregate?: InputMaybe<TokenActivitiesAggregateOrderBy>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"address_version_from_events\" */\nexport enum AddressVersionFromEventsSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type AddressVersionFromEventsStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AddressVersionFromEventsStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AddressVersionFromEventsStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"address_version_from_events\" */\nexport type AddressVersionFromEventsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AddressVersionFromEventsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AddressVersionFromEventsStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AddressVersionFromEventsSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AddressVersionFromEventsVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AddressVersionFromEventsVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AddressVersionFromEventsVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResources = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An array relationship */\n  coin_activities: Array<CoinActivities>;\n  /** An aggregate relationship */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** An array relationship */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** An array relationship */\n  token_activities: Array<TokenActivities>;\n  /** An aggregate relationship */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** An array relationship */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** An aggregate relationship */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** aggregated selection of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesAggregate = {\n  aggregate?: Maybe<AddressVersionFromMoveResourcesAggregateFields>;\n  nodes: Array<AddressVersionFromMoveResources>;\n};\n\n/** aggregate fields of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesAggregateFields = {\n  avg?: Maybe<AddressVersionFromMoveResourcesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AddressVersionFromMoveResourcesMaxFields>;\n  min?: Maybe<AddressVersionFromMoveResourcesMinFields>;\n  stddev?: Maybe<AddressVersionFromMoveResourcesStddevFields>;\n  stddev_pop?: Maybe<AddressVersionFromMoveResourcesStddevPopFields>;\n  stddev_samp?: Maybe<AddressVersionFromMoveResourcesStddevSampFields>;\n  sum?: Maybe<AddressVersionFromMoveResourcesSumFields>;\n  var_pop?: Maybe<AddressVersionFromMoveResourcesVarPopFields>;\n  var_samp?: Maybe<AddressVersionFromMoveResourcesVarSampFields>;\n  variance?: Maybe<AddressVersionFromMoveResourcesVarianceFields>;\n};\n\n/** aggregate fields of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AddressVersionFromMoveResourcesAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"address_version_from_move_resources\". All fields are combined with a logical 'AND'. */\nexport type AddressVersionFromMoveResourcesBoolExp = {\n  _and?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;\n  _not?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n  _or?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  coin_activities?: InputMaybe<CoinActivitiesBoolExp>;\n  coin_activities_aggregate?: InputMaybe<CoinActivitiesAggregateBoolExp>;\n  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  token_activities?: InputMaybe<TokenActivitiesBoolExp>;\n  token_activities_aggregate?: InputMaybe<TokenActivitiesAggregateBoolExp>;\n  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AddressVersionFromMoveResourcesMaxFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AddressVersionFromMoveResourcesMinFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"address_version_from_move_resources\". */\nexport type AddressVersionFromMoveResourcesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  coin_activities_aggregate?: InputMaybe<CoinActivitiesAggregateOrderBy>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;\n  token_activities_aggregate?: InputMaybe<TokenActivitiesAggregateOrderBy>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"address_version_from_move_resources\" */\nexport enum AddressVersionFromMoveResourcesSelectColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type AddressVersionFromMoveResourcesStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AddressVersionFromMoveResourcesStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AddressVersionFromMoveResourcesStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AddressVersionFromMoveResourcesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AddressVersionFromMoveResourcesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AddressVersionFromMoveResourcesSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AddressVersionFromMoveResourcesVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AddressVersionFromMoveResourcesVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AddressVersionFromMoveResourcesVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'. */\nexport type BigintComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"bigint\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"bigint\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactions = {\n  block_height: Scalars[\"bigint\"][\"output\"];\n  epoch: Scalars[\"bigint\"][\"output\"];\n  failed_proposer_indices: Scalars[\"jsonb\"][\"output\"];\n  id: Scalars[\"String\"][\"output\"];\n  previous_block_votes_bitvec: Scalars[\"jsonb\"][\"output\"];\n  proposer: Scalars[\"String\"][\"output\"];\n  round: Scalars[\"bigint\"][\"output\"];\n  timestamp: Scalars[\"timestamp\"][\"output\"];\n  version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsFailedProposerIndicesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsPreviousBlockVotesBitvecArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"block_metadata_transactions\". All fields are combined with a logical 'AND'. */\nexport type BlockMetadataTransactionsBoolExp = {\n  _and?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;\n  _not?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n  _or?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  epoch?: InputMaybe<BigintComparisonExp>;\n  failed_proposer_indices?: InputMaybe<JsonbComparisonExp>;\n  id?: InputMaybe<StringComparisonExp>;\n  previous_block_votes_bitvec?: InputMaybe<JsonbComparisonExp>;\n  proposer?: InputMaybe<StringComparisonExp>;\n  round?: InputMaybe<BigintComparisonExp>;\n  timestamp?: InputMaybe<TimestampComparisonExp>;\n  version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"block_metadata_transactions\". */\nexport type BlockMetadataTransactionsOrderBy = {\n  block_height?: InputMaybe<OrderBy>;\n  epoch?: InputMaybe<OrderBy>;\n  failed_proposer_indices?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  previous_block_votes_bitvec?: InputMaybe<OrderBy>;\n  proposer?: InputMaybe<OrderBy>;\n  round?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"block_metadata_transactions\" */\nexport enum BlockMetadataTransactionsSelectColumn {\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  Epoch = \"epoch\",\n  /** column name */\n  FailedProposerIndices = \"failed_proposer_indices\",\n  /** column name */\n  Id = \"id\",\n  /** column name */\n  PreviousBlockVotesBitvec = \"previous_block_votes_bitvec\",\n  /** column name */\n  Proposer = \"proposer\",\n  /** column name */\n  Round = \"round\",\n  /** column name */\n  Timestamp = \"timestamp\",\n  /** column name */\n  Version = \"version\",\n}\n\n/** Streaming cursor of the table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: BlockMetadataTransactionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type BlockMetadataTransactionsStreamCursorValueInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  failed_proposer_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  proposer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  round?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"coin_activities\" */\nexport type CoinActivities = {\n  activity_type: Scalars[\"String\"][\"output\"];\n  amount: Scalars[\"numeric\"][\"output\"];\n  /** An array relationship */\n  aptos_names: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  aptos_names_aggregate: CurrentAptosNamesAggregate;\n  block_height: Scalars[\"bigint\"][\"output\"];\n  /** An object relationship */\n  coin_info?: Maybe<CoinInfos>;\n  coin_type: Scalars[\"String\"][\"output\"];\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address: Scalars[\"String\"][\"output\"];\n  event_creation_number: Scalars[\"bigint\"][\"output\"];\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number: Scalars[\"bigint\"][\"output\"];\n  is_gas_fee: Scalars[\"Boolean\"][\"output\"];\n  is_transaction_success: Scalars[\"Boolean\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  storage_refund_amount: Scalars[\"numeric\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"coin_activities\" */\nexport type CoinActivitiesAptosNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"coin_activities\" */\nexport type CoinActivitiesAptosNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** aggregated selection of \"coin_activities\" */\nexport type CoinActivitiesAggregate = {\n  aggregate?: Maybe<CoinActivitiesAggregateFields>;\n  nodes: Array<CoinActivities>;\n};\n\nexport type CoinActivitiesAggregateBoolExp = {\n  bool_and?: InputMaybe<CoinActivitiesAggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<CoinActivitiesAggregateBoolExpBoolOr>;\n  count?: InputMaybe<CoinActivitiesAggregateBoolExpCount>;\n};\n\nexport type CoinActivitiesAggregateBoolExpBoolAnd = {\n  arguments: CoinActivitiesSelectColumnCoinActivitiesAggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CoinActivitiesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CoinActivitiesAggregateBoolExpBoolOr = {\n  arguments: CoinActivitiesSelectColumnCoinActivitiesAggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CoinActivitiesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CoinActivitiesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CoinActivitiesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"coin_activities\" */\nexport type CoinActivitiesAggregateFields = {\n  avg?: Maybe<CoinActivitiesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CoinActivitiesMaxFields>;\n  min?: Maybe<CoinActivitiesMinFields>;\n  stddev?: Maybe<CoinActivitiesStddevFields>;\n  stddev_pop?: Maybe<CoinActivitiesStddevPopFields>;\n  stddev_samp?: Maybe<CoinActivitiesStddevSampFields>;\n  sum?: Maybe<CoinActivitiesSumFields>;\n  var_pop?: Maybe<CoinActivitiesVarPopFields>;\n  var_samp?: Maybe<CoinActivitiesVarSampFields>;\n  variance?: Maybe<CoinActivitiesVarianceFields>;\n};\n\n/** aggregate fields of \"coin_activities\" */\nexport type CoinActivitiesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"coin_activities\" */\nexport type CoinActivitiesAggregateOrderBy = {\n  avg?: InputMaybe<CoinActivitiesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<CoinActivitiesMaxOrderBy>;\n  min?: InputMaybe<CoinActivitiesMinOrderBy>;\n  stddev?: InputMaybe<CoinActivitiesStddevOrderBy>;\n  stddev_pop?: InputMaybe<CoinActivitiesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<CoinActivitiesStddevSampOrderBy>;\n  sum?: InputMaybe<CoinActivitiesSumOrderBy>;\n  var_pop?: InputMaybe<CoinActivitiesVarPopOrderBy>;\n  var_samp?: InputMaybe<CoinActivitiesVarSampOrderBy>;\n  variance?: InputMaybe<CoinActivitiesVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type CoinActivitiesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"coin_activities\" */\nexport type CoinActivitiesAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"coin_activities\". All fields are combined with a logical 'AND'. */\nexport type CoinActivitiesBoolExp = {\n  _and?: InputMaybe<Array<CoinActivitiesBoolExp>>;\n  _not?: InputMaybe<CoinActivitiesBoolExp>;\n  _or?: InputMaybe<Array<CoinActivitiesBoolExp>>;\n  activity_type?: InputMaybe<StringComparisonExp>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  aptos_names?: InputMaybe<CurrentAptosNamesBoolExp>;\n  aptos_names_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  coin_info?: InputMaybe<CoinInfosBoolExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_account_address?: InputMaybe<StringComparisonExp>;\n  event_creation_number?: InputMaybe<BigintComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_sequence_number?: InputMaybe<BigintComparisonExp>;\n  is_gas_fee?: InputMaybe<BooleanComparisonExp>;\n  is_transaction_success?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_refund_amount?: InputMaybe<NumericComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CoinActivitiesMaxFields = {\n  activity_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"coin_activities\" */\nexport type CoinActivitiesMaxOrderBy = {\n  activity_type?: InputMaybe<OrderBy>;\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type CoinActivitiesMinFields = {\n  activity_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"coin_activities\" */\nexport type CoinActivitiesMinOrderBy = {\n  activity_type?: InputMaybe<OrderBy>;\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"coin_activities\". */\nexport type CoinActivitiesOrderBy = {\n  activity_type?: InputMaybe<OrderBy>;\n  amount?: InputMaybe<OrderBy>;\n  aptos_names_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  coin_info?: InputMaybe<CoinInfosOrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  is_gas_fee?: InputMaybe<OrderBy>;\n  is_transaction_success?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"coin_activities\" */\nexport enum CoinActivitiesSelectColumn {\n  /** column name */\n  ActivityType = \"activity_type\",\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventCreationNumber = \"event_creation_number\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventSequenceNumber = \"event_sequence_number\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** select \"coin_activities_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"coin_activities\" */\nexport enum CoinActivitiesSelectColumnCoinActivitiesAggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n}\n\n/** select \"coin_activities_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"coin_activities\" */\nexport enum CoinActivitiesSelectColumnCoinActivitiesAggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n}\n\n/** aggregate stddev on columns */\nexport type CoinActivitiesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"coin_activities\" */\nexport type CoinActivitiesStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CoinActivitiesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"coin_activities\" */\nexport type CoinActivitiesStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CoinActivitiesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"coin_activities\" */\nexport type CoinActivitiesStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"coin_activities\" */\nexport type CoinActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinActivitiesStreamCursorValueInput = {\n  activity_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CoinActivitiesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"coin_activities\" */\nexport type CoinActivitiesSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type CoinActivitiesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"coin_activities\" */\nexport type CoinActivitiesVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type CoinActivitiesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"coin_activities\" */\nexport type CoinActivitiesVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type CoinActivitiesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"coin_activities\" */\nexport type CoinActivitiesVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"coin_balances\" */\nexport type CoinBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"coin_balances\". All fields are combined with a logical 'AND'. */\nexport type CoinBalancesBoolExp = {\n  _and?: InputMaybe<Array<CoinBalancesBoolExp>>;\n  _not?: InputMaybe<CoinBalancesBoolExp>;\n  _or?: InputMaybe<Array<CoinBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"coin_balances\". */\nexport type CoinBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"coin_balances\" */\nexport enum CoinBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** Streaming cursor of the table \"coin_balances\" */\nexport type CoinBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"coin_infos\" */\nexport type CoinInfos = {\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  decimals: Scalars[\"Int\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  supply_aggregator_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  symbol: Scalars[\"String\"][\"output\"];\n  transaction_created_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version_created: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"coin_infos\". All fields are combined with a logical 'AND'. */\nexport type CoinInfosBoolExp = {\n  _and?: InputMaybe<Array<CoinInfosBoolExp>>;\n  _not?: InputMaybe<CoinInfosBoolExp>;\n  _or?: InputMaybe<Array<CoinInfosBoolExp>>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  decimals?: InputMaybe<IntComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_handle?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_key?: InputMaybe<StringComparisonExp>;\n  symbol?: InputMaybe<StringComparisonExp>;\n  transaction_created_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version_created?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"coin_infos\". */\nexport type CoinInfosOrderBy = {\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  supply_aggregator_table_handle?: InputMaybe<OrderBy>;\n  supply_aggregator_table_key?: InputMaybe<OrderBy>;\n  symbol?: InputMaybe<OrderBy>;\n  transaction_created_timestamp?: InputMaybe<OrderBy>;\n  transaction_version_created?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"coin_infos\" */\nexport enum CoinInfosSelectColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  SupplyAggregatorTableHandle = \"supply_aggregator_table_handle\",\n  /** column name */\n  SupplyAggregatorTableKey = \"supply_aggregator_table_key\",\n  /** column name */\n  Symbol = \"symbol\",\n  /** column name */\n  TransactionCreatedTimestamp = \"transaction_created_timestamp\",\n  /** column name */\n  TransactionVersionCreated = \"transaction_version_created\",\n}\n\n/** Streaming cursor of the table \"coin_infos\" */\nexport type CoinInfosStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinInfosStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinInfosStreamCursorValueInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_created_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version_created?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"coin_supply\" */\nexport type CoinSupply = {\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  transaction_epoch: Scalars[\"bigint\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"coin_supply\". All fields are combined with a logical 'AND'. */\nexport type CoinSupplyBoolExp = {\n  _and?: InputMaybe<Array<CoinSupplyBoolExp>>;\n  _not?: InputMaybe<CoinSupplyBoolExp>;\n  _or?: InputMaybe<Array<CoinSupplyBoolExp>>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  transaction_epoch?: InputMaybe<BigintComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"coin_supply\". */\nexport type CoinSupplyOrderBy = {\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  transaction_epoch?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"coin_supply\" */\nexport enum CoinSupplySelectColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TransactionEpoch = \"transaction_epoch\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** Streaming cursor of the table \"coin_supply\" */\nexport type CoinSupplyStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinSupplyStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinSupplyStreamCursorValueInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"collection_datas\" */\nexport type CollectionDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"collection_datas\". All fields are combined with a logical 'AND'. */\nexport type CollectionDatasBoolExp = {\n  _and?: InputMaybe<Array<CollectionDatasBoolExp>>;\n  _not?: InputMaybe<CollectionDatasBoolExp>;\n  _or?: InputMaybe<Array<CollectionDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"collection_datas\". */\nexport type CollectionDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"collection_datas\" */\nexport enum CollectionDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** Streaming cursor of the table \"collection_datas\" */\nexport type CollectionDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CollectionDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CollectionDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_ans_lookup\" */\nexport type CurrentAnsLookup = {\n  /** An array relationship */\n  all_token_ownerships: Array<CurrentTokenOwnerships>;\n  /** An aggregate relationship */\n  all_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;\n  domain: Scalars[\"String\"][\"output\"];\n  expiration_timestamp: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_ans_lookup\" */\nexport type CurrentAnsLookupAllTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\n/** columns and relationships of \"current_ans_lookup\" */\nexport type CurrentAnsLookupAllTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\n/** Boolean expression to filter rows from the table \"current_ans_lookup\". All fields are combined with a logical 'AND'. */\nexport type CurrentAnsLookupBoolExp = {\n  _and?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;\n  _not?: InputMaybe<CurrentAnsLookupBoolExp>;\n  _or?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;\n  all_token_ownerships?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n  all_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsAggregateBoolExp>;\n  domain?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_ans_lookup\". */\nexport type CurrentAnsLookupOrderBy = {\n  all_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsAggregateOrderBy>;\n  domain?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_ans_lookup\" */\nexport enum CurrentAnsLookupSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n}\n\n/** Streaming cursor of the table \"current_ans_lookup\" */\nexport type CurrentAnsLookupStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAnsLookupStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAnsLookupStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2 = {\n  domain: Scalars[\"String\"][\"output\"];\n  expiration_timestamp: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain: Scalars[\"String\"][\"output\"];\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_ans_lookup_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentAnsLookupV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;\n  _not?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_ans_lookup_v2\". */\nexport type CurrentAnsLookupV2OrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_ans_lookup_v2\" */\nexport enum CurrentAnsLookupV2SelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** Streaming cursor of the table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAnsLookupV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAnsLookupV2StreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_aptos_names\" */\nexport type CurrentAptosNames = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  domain_expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  domain_with_suffix?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  is_active?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  /** An object relationship */\n  is_domain_owner?: Maybe<CurrentAptosNames>;\n  is_primary?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_aptos_names\" */\nexport type CurrentAptosNamesAggregate = {\n  aggregate?: Maybe<CurrentAptosNamesAggregateFields>;\n  nodes: Array<CurrentAptosNames>;\n};\n\nexport type CurrentAptosNamesAggregateBoolExp = {\n  bool_and?: InputMaybe<CurrentAptosNamesAggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<CurrentAptosNamesAggregateBoolExpBoolOr>;\n  count?: InputMaybe<CurrentAptosNamesAggregateBoolExpCount>;\n};\n\nexport type CurrentAptosNamesAggregateBoolExpBoolAnd = {\n  arguments: CurrentAptosNamesSelectColumnCurrentAptosNamesAggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentAptosNamesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentAptosNamesAggregateBoolExpBoolOr = {\n  arguments: CurrentAptosNamesSelectColumnCurrentAptosNamesAggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentAptosNamesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentAptosNamesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentAptosNamesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"current_aptos_names\" */\nexport type CurrentAptosNamesAggregateFields = {\n  avg?: Maybe<CurrentAptosNamesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentAptosNamesMaxFields>;\n  min?: Maybe<CurrentAptosNamesMinFields>;\n  stddev?: Maybe<CurrentAptosNamesStddevFields>;\n  stddev_pop?: Maybe<CurrentAptosNamesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentAptosNamesStddevSampFields>;\n  sum?: Maybe<CurrentAptosNamesSumFields>;\n  var_pop?: Maybe<CurrentAptosNamesVarPopFields>;\n  var_samp?: Maybe<CurrentAptosNamesVarSampFields>;\n  variance?: Maybe<CurrentAptosNamesVarianceFields>;\n};\n\n/** aggregate fields of \"current_aptos_names\" */\nexport type CurrentAptosNamesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"current_aptos_names\" */\nexport type CurrentAptosNamesAggregateOrderBy = {\n  avg?: InputMaybe<CurrentAptosNamesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<CurrentAptosNamesMaxOrderBy>;\n  min?: InputMaybe<CurrentAptosNamesMinOrderBy>;\n  stddev?: InputMaybe<CurrentAptosNamesStddevOrderBy>;\n  stddev_pop?: InputMaybe<CurrentAptosNamesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<CurrentAptosNamesStddevSampOrderBy>;\n  sum?: InputMaybe<CurrentAptosNamesSumOrderBy>;\n  var_pop?: InputMaybe<CurrentAptosNamesVarPopOrderBy>;\n  var_samp?: InputMaybe<CurrentAptosNamesVarSampOrderBy>;\n  variance?: InputMaybe<CurrentAptosNamesVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentAptosNamesAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesAvgOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"current_aptos_names\". All fields are combined with a logical 'AND'. */\nexport type CurrentAptosNamesBoolExp = {\n  _and?: InputMaybe<Array<CurrentAptosNamesBoolExp>>;\n  _not?: InputMaybe<CurrentAptosNamesBoolExp>;\n  _or?: InputMaybe<Array<CurrentAptosNamesBoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  domain_expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  domain_with_suffix?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  is_active?: InputMaybe<BooleanComparisonExp>;\n  is_domain_owner?: InputMaybe<CurrentAptosNamesBoolExp>;\n  is_primary?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentAptosNamesMaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  domain_expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  domain_with_suffix?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesMaxOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  domain_expiration_timestamp?: InputMaybe<OrderBy>;\n  domain_with_suffix?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type CurrentAptosNamesMinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  domain_expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  domain_with_suffix?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesMinOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  domain_expiration_timestamp?: InputMaybe<OrderBy>;\n  domain_with_suffix?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"current_aptos_names\". */\nexport type CurrentAptosNamesOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  domain_expiration_timestamp?: InputMaybe<OrderBy>;\n  domain_with_suffix?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  is_active?: InputMaybe<OrderBy>;\n  is_domain_owner?: InputMaybe<CurrentAptosNamesOrderBy>;\n  is_primary?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_aptos_names\" */\nexport enum CurrentAptosNamesSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  DomainExpirationTimestamp = \"domain_expiration_timestamp\",\n  /** column name */\n  DomainWithSuffix = \"domain_with_suffix\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  IsActive = \"is_active\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  SubdomainExpirationPolicy = \"subdomain_expiration_policy\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** select \"current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"current_aptos_names\" */\nexport enum CurrentAptosNamesSelectColumnCurrentAptosNamesAggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsActive = \"is_active\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n}\n\n/** select \"current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"current_aptos_names\" */\nexport enum CurrentAptosNamesSelectColumnCurrentAptosNamesAggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsActive = \"is_active\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentAptosNamesStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesStddevOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentAptosNamesStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesStddevPopOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentAptosNamesStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesStddevSampOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"current_aptos_names\" */\nexport type CurrentAptosNamesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAptosNamesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAptosNamesStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  domain_expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  domain_with_suffix?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_active?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentAptosNamesSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesSumOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentAptosNamesVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesVarPopOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentAptosNamesVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesVarSampOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentAptosNamesVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"current_aptos_names\" */\nexport type CurrentAptosNamesVarianceOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"current_coin_balances\" */\nexport type CurrentCoinBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  /** An object relationship */\n  coin_info?: Maybe<CoinInfos>;\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_coin_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentCoinBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentCoinBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  coin_info?: InputMaybe<CoinInfosBoolExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_coin_balances\". */\nexport type CurrentCoinBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  coin_info?: InputMaybe<CoinInfosOrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_coin_balances\" */\nexport enum CurrentCoinBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n}\n\n/** Streaming cursor of the table \"current_coin_balances\" */\nexport type CurrentCoinBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCoinBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCoinBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_collection_datas\" */\nexport type CurrentCollectionDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_collection_datas\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionDatasBoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;\n  _not?: InputMaybe<CurrentCollectionDatasBoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_collection_datas\". */\nexport type CurrentCollectionDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_collection_datas\" */\nexport enum CurrentCollectionDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** Streaming cursor of the table \"current_collection_datas\" */\nexport type CurrentCollectionDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2View = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  current_collection?: Maybe<CurrentCollectionsV2>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  single_token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewAggregate = {\n  aggregate?: Maybe<CurrentCollectionOwnershipV2ViewAggregateFields>;\n  nodes: Array<CurrentCollectionOwnershipV2View>;\n};\n\n/** aggregate fields of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewAggregateFields = {\n  avg?: Maybe<CurrentCollectionOwnershipV2ViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCollectionOwnershipV2ViewMaxFields>;\n  min?: Maybe<CurrentCollectionOwnershipV2ViewMinFields>;\n  stddev?: Maybe<CurrentCollectionOwnershipV2ViewStddevFields>;\n  stddev_pop?: Maybe<CurrentCollectionOwnershipV2ViewStddevPopFields>;\n  stddev_samp?: Maybe<CurrentCollectionOwnershipV2ViewStddevSampFields>;\n  sum?: Maybe<CurrentCollectionOwnershipV2ViewSumFields>;\n  var_pop?: Maybe<CurrentCollectionOwnershipV2ViewVarPopFields>;\n  var_samp?: Maybe<CurrentCollectionOwnershipV2ViewVarSampFields>;\n  variance?: Maybe<CurrentCollectionOwnershipV2ViewVarianceFields>;\n};\n\n/** aggregate fields of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCollectionOwnershipV2ViewAvgFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_collection_ownership_v2_view\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionOwnershipV2ViewBoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;\n  _not?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  collection_uri?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  distinct_tokens?: InputMaybe<BigintComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  single_token_uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCollectionOwnershipV2ViewMaxFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  single_token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCollectionOwnershipV2ViewMinFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  single_token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"current_collection_ownership_v2_view\". */\nexport type CurrentCollectionOwnershipV2ViewOrderBy = {\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  collection_uri?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  distinct_tokens?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  single_token_uri?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_collection_ownership_v2_view\" */\nexport enum CurrentCollectionOwnershipV2ViewSelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CollectionUri = \"collection_uri\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DistinctTokens = \"distinct_tokens\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  SingleTokenUri = \"single_token_uri\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentCollectionOwnershipV2ViewStddevFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCollectionOwnershipV2ViewStddevPopFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCollectionOwnershipV2ViewStddevSampFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionOwnershipV2ViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionOwnershipV2ViewStreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  distinct_tokens?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  single_token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCollectionOwnershipV2ViewSumFields = {\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCollectionOwnershipV2ViewVarPopFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCollectionOwnershipV2ViewVarSampFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCollectionOwnershipV2ViewVarianceFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_collections_v2\" */\nexport type CurrentCollectionsV2 = {\n  /** An object relationship */\n  cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  current_supply: Scalars[\"numeric\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  mutable_description?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  mutable_uri?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  uri: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_collections_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionsV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;\n  _not?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_supply?: InputMaybe<NumericComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  max_supply?: InputMaybe<NumericComparisonExp>;\n  mutable_description?: InputMaybe<BooleanComparisonExp>;\n  mutable_uri?: InputMaybe<BooleanComparisonExp>;\n  table_handle_v1?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  total_minted_v2?: InputMaybe<NumericComparisonExp>;\n  uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_collections_v2\". */\nexport type CurrentCollectionsV2OrderBy = {\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_supply?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  max_supply?: InputMaybe<OrderBy>;\n  mutable_description?: InputMaybe<OrderBy>;\n  mutable_uri?: InputMaybe<OrderBy>;\n  table_handle_v1?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  total_minted_v2?: InputMaybe<OrderBy>;\n  uri?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_collections_v2\" */\nexport enum CurrentCollectionsV2SelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  CurrentSupply = \"current_supply\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  MaxSupply = \"max_supply\",\n  /** column name */\n  MutableDescription = \"mutable_description\",\n  /** column name */\n  MutableUri = \"mutable_uri\",\n  /** column name */\n  TableHandleV1 = \"table_handle_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TotalMintedV2 = \"total_minted_v2\",\n  /** column name */\n  Uri = \"uri\",\n}\n\n/** Streaming cursor of the table \"current_collections_v2\" */\nexport type CurrentCollectionsV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionsV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionsV2StreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalances = {\n  active_table_handle: Scalars[\"String\"][\"output\"];\n  inactive_table_handle: Scalars[\"String\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  operator_commission_percentage: Scalars[\"numeric\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  total_coins: Scalars[\"numeric\"][\"output\"];\n  total_shares: Scalars[\"numeric\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_delegated_staking_pool_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentDelegatedStakingPoolBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;\n  active_table_handle?: InputMaybe<StringComparisonExp>;\n  inactive_table_handle?: InputMaybe<StringComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  operator_commission_percentage?: InputMaybe<NumericComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  total_coins?: InputMaybe<NumericComparisonExp>;\n  total_shares?: InputMaybe<NumericComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_delegated_staking_pool_balances\". */\nexport type CurrentDelegatedStakingPoolBalancesOrderBy = {\n  active_table_handle?: InputMaybe<OrderBy>;\n  inactive_table_handle?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  operator_commission_percentage?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  total_coins?: InputMaybe<OrderBy>;\n  total_shares?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_delegated_staking_pool_balances\" */\nexport enum CurrentDelegatedStakingPoolBalancesSelectColumn {\n  /** column name */\n  ActiveTableHandle = \"active_table_handle\",\n  /** column name */\n  InactiveTableHandle = \"inactive_table_handle\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OperatorCommissionPercentage = \"operator_commission_percentage\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TotalCoins = \"total_coins\",\n  /** column name */\n  TotalShares = \"total_shares\",\n}\n\n/** Streaming cursor of the table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentDelegatedStakingPoolBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentDelegatedStakingPoolBalancesStreamCursorValueInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_delegated_voter\" */\nexport type CurrentDelegatedVoter = {\n  delegation_pool_address: Scalars[\"String\"][\"output\"];\n  delegator_address: Scalars[\"String\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  pending_voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_delegated_voter\". All fields are combined with a logical 'AND'. */\nexport type CurrentDelegatedVoterBoolExp = {\n  _and?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;\n  _not?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n  _or?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;\n  delegation_pool_address?: InputMaybe<StringComparisonExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  pending_voter?: InputMaybe<StringComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  voter?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_delegated_voter\". */\nexport type CurrentDelegatedVoterOrderBy = {\n  delegation_pool_address?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  pending_voter?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  voter?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_delegated_voter\" */\nexport enum CurrentDelegatedVoterSelectColumn {\n  /** column name */\n  DelegationPoolAddress = \"delegation_pool_address\",\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PendingVoter = \"pending_voter\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  Voter = \"voter\",\n}\n\n/** Streaming cursor of the table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentDelegatedVoterStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentDelegatedVoterStreamCursorValueInput = {\n  delegation_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  pending_voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_delegator_balances\" */\nexport type CurrentDelegatorBalances = {\n  /** An object relationship */\n  current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  delegator_address: Scalars[\"String\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  parent_table_handle: Scalars[\"String\"][\"output\"];\n  pool_address: Scalars[\"String\"][\"output\"];\n  pool_type: Scalars[\"String\"][\"output\"];\n  shares: Scalars[\"numeric\"][\"output\"];\n  /** An object relationship */\n  staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;\n  table_handle: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_delegator_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentDelegatorBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  parent_table_handle?: InputMaybe<StringComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  pool_type?: InputMaybe<StringComparisonExp>;\n  shares?: InputMaybe<NumericComparisonExp>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_delegator_balances\". */\nexport type CurrentDelegatorBalancesOrderBy = {\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  parent_table_handle?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  pool_type?: InputMaybe<OrderBy>;\n  shares?: InputMaybe<OrderBy>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_delegator_balances\" */\nexport enum CurrentDelegatorBalancesSelectColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ParentTableHandle = \"parent_table_handle\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  PoolType = \"pool_type\",\n  /** column name */\n  Shares = \"shares\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\n/** Streaming cursor of the table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentDelegatorBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentDelegatorBalancesStreamCursorValueInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  asset_type: Scalars[\"String\"][\"output\"];\n  is_frozen: Scalars[\"Boolean\"][\"output\"];\n  is_primary: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  /** An object relationship */\n  metadata?: Maybe<FungibleAssetMetadata>;\n  owner_address: Scalars[\"String\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesAggregate = {\n  aggregate?: Maybe<CurrentFungibleAssetBalancesAggregateFields>;\n  nodes: Array<CurrentFungibleAssetBalances>;\n};\n\n/** aggregate fields of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesAggregateFields = {\n  avg?: Maybe<CurrentFungibleAssetBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentFungibleAssetBalancesMaxFields>;\n  min?: Maybe<CurrentFungibleAssetBalancesMinFields>;\n  stddev?: Maybe<CurrentFungibleAssetBalancesStddevFields>;\n  stddev_pop?: Maybe<CurrentFungibleAssetBalancesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentFungibleAssetBalancesStddevSampFields>;\n  sum?: Maybe<CurrentFungibleAssetBalancesSumFields>;\n  var_pop?: Maybe<CurrentFungibleAssetBalancesVarPopFields>;\n  var_samp?: Maybe<CurrentFungibleAssetBalancesVarSampFields>;\n  variance?: Maybe<CurrentFungibleAssetBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentFungibleAssetBalancesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_fungible_asset_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentFungibleAssetBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  is_frozen?: InputMaybe<BooleanComparisonExp>;\n  is_primary?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentFungibleAssetBalancesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentFungibleAssetBalancesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"current_fungible_asset_balances\". */\nexport type CurrentFungibleAssetBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  is_frozen?: InputMaybe<OrderBy>;\n  is_primary?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_fungible_asset_balances\" */\nexport enum CurrentFungibleAssetBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentFungibleAssetBalancesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentFungibleAssetBalancesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentFungibleAssetBalancesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentFungibleAssetBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentFungibleAssetBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentFungibleAssetBalancesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentFungibleAssetBalancesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentFungibleAssetBalancesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentFungibleAssetBalancesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_objects\" */\nexport type CurrentObjects = {\n  allow_ungated_transfer: Scalars[\"Boolean\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_guid_creation_num: Scalars[\"numeric\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  object_address: Scalars[\"String\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  state_key_hash: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_objects\". All fields are combined with a logical 'AND'. */\nexport type CurrentObjectsBoolExp = {\n  _and?: InputMaybe<Array<CurrentObjectsBoolExp>>;\n  _not?: InputMaybe<CurrentObjectsBoolExp>;\n  _or?: InputMaybe<Array<CurrentObjectsBoolExp>>;\n  allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_guid_creation_num?: InputMaybe<NumericComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  object_address?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  state_key_hash?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_objects\". */\nexport type CurrentObjectsOrderBy = {\n  allow_ungated_transfer?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_guid_creation_num?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  object_address?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  state_key_hash?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_objects\" */\nexport enum CurrentObjectsSelectColumn {\n  /** column name */\n  AllowUngatedTransfer = \"allow_ungated_transfer\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastGuidCreationNum = \"last_guid_creation_num\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n}\n\n/** Streaming cursor of the table \"current_objects\" */\nexport type CurrentObjectsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentObjectsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentObjectsStreamCursorValueInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoter = {\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  operator_address: Scalars[\"String\"][\"output\"];\n  /** An array relationship */\n  operator_aptos_name: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  operator_aptos_name_aggregate: CurrentAptosNamesAggregate;\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  voter_address: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterOperatorAptosNameArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterOperatorAptosNameAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** Boolean expression to filter rows from the table \"current_staking_pool_voter\". All fields are combined with a logical 'AND'. */\nexport type CurrentStakingPoolVoterBoolExp = {\n  _and?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;\n  _not?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n  _or?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  operator_address?: InputMaybe<StringComparisonExp>;\n  operator_aptos_name?: InputMaybe<CurrentAptosNamesBoolExp>;\n  operator_aptos_name_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  voter_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_staking_pool_voter\". */\nexport type CurrentStakingPoolVoterOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  operator_address?: InputMaybe<OrderBy>;\n  operator_aptos_name_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  voter_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_staking_pool_voter\" */\nexport enum CurrentStakingPoolVoterSelectColumn {\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OperatorAddress = \"operator_address\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  VoterAddress = \"voter_address\",\n}\n\n/** Streaming cursor of the table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentStakingPoolVoterStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentStakingPoolVoterStreamCursorValueInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_table_items\" */\nexport type CurrentTableItems = {\n  decoded_key: Scalars[\"jsonb\"][\"output\"];\n  decoded_value?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  key: Scalars[\"String\"][\"output\"];\n  key_hash: Scalars[\"String\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_table_items\" */\nexport type CurrentTableItemsDecodedKeyArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_table_items\" */\nexport type CurrentTableItemsDecodedValueArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_table_items\". All fields are combined with a logical 'AND'. */\nexport type CurrentTableItemsBoolExp = {\n  _and?: InputMaybe<Array<CurrentTableItemsBoolExp>>;\n  _not?: InputMaybe<CurrentTableItemsBoolExp>;\n  _or?: InputMaybe<Array<CurrentTableItemsBoolExp>>;\n  decoded_key?: InputMaybe<JsonbComparisonExp>;\n  decoded_value?: InputMaybe<JsonbComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  key?: InputMaybe<StringComparisonExp>;\n  key_hash?: InputMaybe<StringComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_table_items\". */\nexport type CurrentTableItemsOrderBy = {\n  decoded_key?: InputMaybe<OrderBy>;\n  decoded_value?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  key?: InputMaybe<OrderBy>;\n  key_hash?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_table_items\" */\nexport enum CurrentTableItemsSelectColumn {\n  /** column name */\n  DecodedKey = \"decoded_key\",\n  /** column name */\n  DecodedValue = \"decoded_value\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  KeyHash = \"key_hash\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\n/** Streaming cursor of the table \"current_table_items\" */\nexport type CurrentTableItemsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTableItemsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTableItemsStreamCursorValueInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_token_datas\" */\nexport type CurrentTokenDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection_data?: Maybe<CurrentCollectionDatas>;\n  default_properties: Scalars[\"jsonb\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  largest_property_version: Scalars[\"numeric\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  payee_address: Scalars[\"String\"][\"output\"];\n  properties_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_points_denominator: Scalars[\"numeric\"][\"output\"];\n  royalty_points_numerator: Scalars[\"numeric\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_datas\" */\nexport type CurrentTokenDatasDefaultPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_datas\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenDatasBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;\n  _not?: InputMaybe<CurrentTokenDatasBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_collection_data?: InputMaybe<CurrentCollectionDatasBoolExp>;\n  default_properties?: InputMaybe<JsonbComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  largest_property_version?: InputMaybe<NumericComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  payee_address?: InputMaybe<StringComparisonExp>;\n  properties_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;\n  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_datas\". */\nexport type CurrentTokenDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_collection_data?: InputMaybe<CurrentCollectionDatasOrderBy>;\n  default_properties?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  largest_property_version?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  payee_address?: InputMaybe<OrderBy>;\n  properties_mutable?: InputMaybe<OrderBy>;\n  royalty_mutable?: InputMaybe<OrderBy>;\n  royalty_points_denominator?: InputMaybe<OrderBy>;\n  royalty_points_numerator?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_token_datas\" */\nexport enum CurrentTokenDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DefaultProperties = \"default_properties\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  LargestPropertyVersion = \"largest_property_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  PropertiesMutable = \"properties_mutable\",\n  /** column name */\n  RoyaltyMutable = \"royalty_mutable\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** Streaming cursor of the table \"current_token_datas\" */\nexport type CurrentTokenDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2 = {\n  /** An object relationship */\n  aptos_name?: Maybe<CurrentAptosNames>;\n  /** An object relationship */\n  cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection?: Maybe<CurrentCollectionsV2>;\n  /** An array relationship */\n  current_token_ownerships: Array<CurrentTokenOwnershipsV2>;\n  /** An aggregate relationship */\n  current_token_ownerships_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  decimals: Scalars[\"bigint\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  token_uri: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2CurrentTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2CurrentTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2TokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_datas_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenDatasV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;\n  _not?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;\n  aptos_name?: InputMaybe<CurrentAptosNamesBoolExp>;\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;\n  decimals?: InputMaybe<BigintComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  largest_property_version_v1?: InputMaybe<NumericComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  token_uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_datas_v2\". */\nexport type CurrentTokenDatasV2OrderBy = {\n  aptos_name?: InputMaybe<CurrentAptosNamesOrderBy>;\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  largest_property_version_v1?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  token_uri?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_token_datas_v2\" */\nexport enum CurrentTokenDatasV2SelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  LargestPropertyVersionV1 = \"largest_property_version_v1\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TokenUri = \"token_uri\",\n}\n\n/** Streaming cursor of the table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenDatasV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenDatasV2StreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_token_ownerships\" */\nexport type CurrentTokenOwnerships = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  /** An object relationship */\n  aptos_name?: Maybe<CurrentAptosNames>;\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection_data?: Maybe<CurrentCollectionDatas>;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatas>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  table_type: Scalars[\"String\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsTokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregate = {\n  aggregate?: Maybe<CurrentTokenOwnershipsAggregateFields>;\n  nodes: Array<CurrentTokenOwnerships>;\n};\n\nexport type CurrentTokenOwnershipsAggregateBoolExp = {\n  count?: InputMaybe<CurrentTokenOwnershipsAggregateBoolExpCount>;\n};\n\nexport type CurrentTokenOwnershipsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregateFields = {\n  avg?: Maybe<CurrentTokenOwnershipsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenOwnershipsMaxFields>;\n  min?: Maybe<CurrentTokenOwnershipsMinFields>;\n  stddev?: Maybe<CurrentTokenOwnershipsStddevFields>;\n  stddev_pop?: Maybe<CurrentTokenOwnershipsStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenOwnershipsStddevSampFields>;\n  sum?: Maybe<CurrentTokenOwnershipsSumFields>;\n  var_pop?: Maybe<CurrentTokenOwnershipsVarPopFields>;\n  var_samp?: Maybe<CurrentTokenOwnershipsVarSampFields>;\n  variance?: Maybe<CurrentTokenOwnershipsVarianceFields>;\n};\n\n/** aggregate fields of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregateOrderBy = {\n  avg?: InputMaybe<CurrentTokenOwnershipsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<CurrentTokenOwnershipsMaxOrderBy>;\n  min?: InputMaybe<CurrentTokenOwnershipsMinOrderBy>;\n  stddev?: InputMaybe<CurrentTokenOwnershipsStddevOrderBy>;\n  stddev_pop?: InputMaybe<CurrentTokenOwnershipsStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<CurrentTokenOwnershipsStddevSampOrderBy>;\n  sum?: InputMaybe<CurrentTokenOwnershipsSumOrderBy>;\n  var_pop?: InputMaybe<CurrentTokenOwnershipsVarPopOrderBy>;\n  var_samp?: InputMaybe<CurrentTokenOwnershipsVarSampOrderBy>;\n  variance?: InputMaybe<CurrentTokenOwnershipsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenOwnershipsAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_ownerships\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenOwnershipsBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;\n  _not?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  aptos_name?: InputMaybe<CurrentAptosNamesBoolExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_collection_data?: InputMaybe<CurrentCollectionDatasBoolExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasBoolExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  table_type?: InputMaybe<StringComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenOwnershipsMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_type?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenOwnershipsMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_type?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"current_token_ownerships\". */\nexport type CurrentTokenOwnershipsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  aptos_name?: InputMaybe<CurrentAptosNamesOrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_collection_data?: InputMaybe<CurrentCollectionDatasOrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasOrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_type?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_token_ownerships\" */\nexport enum CurrentTokenOwnershipsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableType = \"table_type\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentTokenOwnershipsStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenOwnershipsStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenOwnershipsStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenOwnershipsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenOwnershipsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenOwnershipsSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2 = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  /** An array relationship */\n  composed_nfts: Array<CurrentTokenOwnershipsV2>;\n  /** An aggregate relationship */\n  composed_nfts_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_soulbound_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  non_transferrable_by_owner?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  owner_address: Scalars[\"String\"][\"output\"];\n  property_version_v1: Scalars[\"numeric\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_properties_mutated_v1?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2ComposedNftsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2ComposedNftsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2TokenPropertiesMutatedV1Args = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2Aggregate = {\n  aggregate?: Maybe<CurrentTokenOwnershipsV2AggregateFields>;\n  nodes: Array<CurrentTokenOwnershipsV2>;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExp = {\n  bool_and?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolOr>;\n  count?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpCount>;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd = {\n  arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExpBoolOr = {\n  arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AggregateFields = {\n  avg?: Maybe<CurrentTokenOwnershipsV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenOwnershipsV2MaxFields>;\n  min?: Maybe<CurrentTokenOwnershipsV2MinFields>;\n  stddev?: Maybe<CurrentTokenOwnershipsV2StddevFields>;\n  stddev_pop?: Maybe<CurrentTokenOwnershipsV2StddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenOwnershipsV2StddevSampFields>;\n  sum?: Maybe<CurrentTokenOwnershipsV2SumFields>;\n  var_pop?: Maybe<CurrentTokenOwnershipsV2VarPopFields>;\n  var_samp?: Maybe<CurrentTokenOwnershipsV2VarSampFields>;\n  variance?: Maybe<CurrentTokenOwnershipsV2VarianceFields>;\n};\n\n/** aggregate fields of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AggregateOrderBy = {\n  avg?: InputMaybe<CurrentTokenOwnershipsV2AvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<CurrentTokenOwnershipsV2MaxOrderBy>;\n  min?: InputMaybe<CurrentTokenOwnershipsV2MinOrderBy>;\n  stddev?: InputMaybe<CurrentTokenOwnershipsV2StddevOrderBy>;\n  stddev_pop?: InputMaybe<CurrentTokenOwnershipsV2StddevPopOrderBy>;\n  stddev_samp?: InputMaybe<CurrentTokenOwnershipsV2StddevSampOrderBy>;\n  sum?: InputMaybe<CurrentTokenOwnershipsV2SumOrderBy>;\n  var_pop?: InputMaybe<CurrentTokenOwnershipsV2VarPopOrderBy>;\n  var_samp?: InputMaybe<CurrentTokenOwnershipsV2VarSampOrderBy>;\n  variance?: InputMaybe<CurrentTokenOwnershipsV2VarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenOwnershipsV2AvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_ownerships_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenOwnershipsV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;\n  _not?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version_v1?: InputMaybe<NumericComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  table_type_v1?: InputMaybe<StringComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenOwnershipsV2MaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2MaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenOwnershipsV2MinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2MinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"current_token_ownerships_v2\". */\nexport type CurrentTokenOwnershipsV2OrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  is_soulbound_v2?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  non_transferrable_by_owner?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_properties_mutated_v1?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2SelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TableTypeV1 = \"table_type_v1\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenPropertiesMutatedV1 = \"token_properties_mutated_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** select \"current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n}\n\n/** select \"current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentTokenOwnershipsV2StddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenOwnershipsV2StddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenOwnershipsV2StddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenOwnershipsV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenOwnershipsV2StreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenOwnershipsV2SumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2SumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenOwnershipsV2VarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2VarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenOwnershipsV2VarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2VarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenOwnershipsV2VarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2VarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenOwnershipsVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenOwnershipsVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenOwnershipsVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaims = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection_data?: Maybe<CurrentCollectionDatas>;\n  /** An object relationship */\n  current_collection_v2?: Maybe<CurrentCollectionsV2>;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatas>;\n  /** An object relationship */\n  current_token_data_v2?: Maybe<CurrentTokenDatasV2>;\n  from_address: Scalars[\"String\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  to_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  token?: Maybe<Tokens>;\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"current_token_pending_claims\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenPendingClaimsBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;\n  _not?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_collection_data?: InputMaybe<CurrentCollectionDatasBoolExp>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasBoolExp>;\n  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  from_address?: InputMaybe<StringComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  to_address?: InputMaybe<StringComparisonExp>;\n  token?: InputMaybe<TokensBoolExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_pending_claims\". */\nexport type CurrentTokenPendingClaimsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_collection_data?: InputMaybe<CurrentCollectionDatasOrderBy>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasOrderBy>;\n  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token?: InputMaybe<TokensOrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_token_pending_claims\" */\nexport enum CurrentTokenPendingClaimsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n}\n\n/** Streaming cursor of the table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenPendingClaimsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenPendingClaimsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** ordering argument of a cursor */\nexport enum CursorOrdering {\n  /** ascending ordering of the cursor */\n  Asc = \"ASC\",\n  /** descending ordering of the cursor */\n  Desc = \"DESC\",\n}\n\n/** columns and relationships of \"delegated_staking_activities\" */\nexport type DelegatedStakingActivities = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  delegator_address: Scalars[\"String\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  event_type: Scalars[\"String\"][\"output\"];\n  pool_address: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** order by aggregate values of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAggregateOrderBy = {\n  avg?: InputMaybe<DelegatedStakingActivitiesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<DelegatedStakingActivitiesMaxOrderBy>;\n  min?: InputMaybe<DelegatedStakingActivitiesMinOrderBy>;\n  stddev?: InputMaybe<DelegatedStakingActivitiesStddevOrderBy>;\n  stddev_pop?: InputMaybe<DelegatedStakingActivitiesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<DelegatedStakingActivitiesStddevSampOrderBy>;\n  sum?: InputMaybe<DelegatedStakingActivitiesSumOrderBy>;\n  var_pop?: InputMaybe<DelegatedStakingActivitiesVarPopOrderBy>;\n  var_samp?: InputMaybe<DelegatedStakingActivitiesVarSampOrderBy>;\n  variance?: InputMaybe<DelegatedStakingActivitiesVarianceOrderBy>;\n};\n\n/** order by avg() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"delegated_staking_activities\". All fields are combined with a logical 'AND'. */\nexport type DelegatedStakingActivitiesBoolExp = {\n  _and?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;\n  _not?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  _or?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_type?: InputMaybe<StringComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** order by max() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by min() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"delegated_staking_activities\". */\nexport type DelegatedStakingActivitiesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"delegated_staking_activities\" */\nexport enum DelegatedStakingActivitiesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventType = \"event_type\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** order by stddev() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by stddev_pop() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by stddev_samp() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatedStakingActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatedStakingActivitiesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** order by sum() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by var_pop() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by var_samp() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by variance() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalances = {\n  active_table_handle: Scalars[\"String\"][\"output\"];\n  inactive_table_handle: Scalars[\"String\"][\"output\"];\n  operator_commission_percentage: Scalars[\"numeric\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  total_coins: Scalars[\"numeric\"][\"output\"];\n  total_shares: Scalars[\"numeric\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesAggregate = {\n  aggregate?: Maybe<DelegatedStakingPoolBalancesAggregateFields>;\n  nodes: Array<DelegatedStakingPoolBalances>;\n};\n\n/** aggregate fields of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesAggregateFields = {\n  avg?: Maybe<DelegatedStakingPoolBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatedStakingPoolBalancesMaxFields>;\n  min?: Maybe<DelegatedStakingPoolBalancesMinFields>;\n  stddev?: Maybe<DelegatedStakingPoolBalancesStddevFields>;\n  stddev_pop?: Maybe<DelegatedStakingPoolBalancesStddevPopFields>;\n  stddev_samp?: Maybe<DelegatedStakingPoolBalancesStddevSampFields>;\n  sum?: Maybe<DelegatedStakingPoolBalancesSumFields>;\n  var_pop?: Maybe<DelegatedStakingPoolBalancesVarPopFields>;\n  var_samp?: Maybe<DelegatedStakingPoolBalancesVarSampFields>;\n  variance?: Maybe<DelegatedStakingPoolBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type DelegatedStakingPoolBalancesAvgFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"delegated_staking_pool_balances\". All fields are combined with a logical 'AND'. */\nexport type DelegatedStakingPoolBalancesBoolExp = {\n  _and?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;\n  _not?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n  _or?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;\n  active_table_handle?: InputMaybe<StringComparisonExp>;\n  inactive_table_handle?: InputMaybe<StringComparisonExp>;\n  operator_commission_percentage?: InputMaybe<NumericComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  total_coins?: InputMaybe<NumericComparisonExp>;\n  total_shares?: InputMaybe<NumericComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type DelegatedStakingPoolBalancesMaxFields = {\n  active_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inactive_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type DelegatedStakingPoolBalancesMinFields = {\n  active_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inactive_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"delegated_staking_pool_balances\". */\nexport type DelegatedStakingPoolBalancesOrderBy = {\n  active_table_handle?: InputMaybe<OrderBy>;\n  inactive_table_handle?: InputMaybe<OrderBy>;\n  operator_commission_percentage?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  total_coins?: InputMaybe<OrderBy>;\n  total_shares?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"delegated_staking_pool_balances\" */\nexport enum DelegatedStakingPoolBalancesSelectColumn {\n  /** column name */\n  ActiveTableHandle = \"active_table_handle\",\n  /** column name */\n  InactiveTableHandle = \"inactive_table_handle\",\n  /** column name */\n  OperatorCommissionPercentage = \"operator_commission_percentage\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TotalCoins = \"total_coins\",\n  /** column name */\n  TotalShares = \"total_shares\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type DelegatedStakingPoolBalancesStddevFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type DelegatedStakingPoolBalancesStddevPopFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type DelegatedStakingPoolBalancesStddevSampFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatedStakingPoolBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatedStakingPoolBalancesStreamCursorValueInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type DelegatedStakingPoolBalancesSumFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type DelegatedStakingPoolBalancesVarPopFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type DelegatedStakingPoolBalancesVarSampFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type DelegatedStakingPoolBalancesVarianceFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"delegated_staking_pools\" */\nexport type DelegatedStakingPools = {\n  /** An object relationship */\n  current_staking_pool?: Maybe<CurrentStakingPoolVoter>;\n  first_transaction_version: Scalars[\"bigint\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"delegated_staking_pools\". All fields are combined with a logical 'AND'. */\nexport type DelegatedStakingPoolsBoolExp = {\n  _and?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;\n  _not?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n  _or?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;\n  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n  first_transaction_version?: InputMaybe<BigintComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"delegated_staking_pools\". */\nexport type DelegatedStakingPoolsOrderBy = {\n  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterOrderBy>;\n  first_transaction_version?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"delegated_staking_pools\" */\nexport enum DelegatedStakingPoolsSelectColumn {\n  /** column name */\n  FirstTransactionVersion = \"first_transaction_version\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n}\n\n/** Streaming cursor of the table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatedStakingPoolsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatedStakingPoolsStreamCursorValueInput = {\n  first_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPool = {\n  /** An object relationship */\n  current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;\n};\n\n/** aggregated selection of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolAggregate = {\n  aggregate?: Maybe<DelegatorDistinctPoolAggregateFields>;\n  nodes: Array<DelegatorDistinctPool>;\n};\n\n/** aggregate fields of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolAggregateFields = {\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatorDistinctPoolMaxFields>;\n  min?: Maybe<DelegatorDistinctPoolMinFields>;\n};\n\n/** aggregate fields of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"delegator_distinct_pool\". All fields are combined with a logical 'AND'. */\nexport type DelegatorDistinctPoolBoolExp = {\n  _and?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;\n  _not?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n  _or?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\n/** aggregate max on columns */\nexport type DelegatorDistinctPoolMaxFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type DelegatorDistinctPoolMinFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"delegator_distinct_pool\". */\nexport type DelegatorDistinctPoolOrderBy = {\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;\n};\n\n/** select columns of table \"delegator_distinct_pool\" */\nexport enum DelegatorDistinctPoolSelectColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n}\n\n/** Streaming cursor of the table \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatorDistinctPoolStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatorDistinctPoolStreamCursorValueInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"events\" */\nexport type Events = {\n  account_address: Scalars[\"String\"][\"output\"];\n  creation_number: Scalars[\"bigint\"][\"output\"];\n  data: Scalars[\"jsonb\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  indexed_type: Scalars[\"String\"][\"output\"];\n  sequence_number: Scalars[\"bigint\"][\"output\"];\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"events\" */\nexport type EventsDataArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"events\". All fields are combined with a logical 'AND'. */\nexport type EventsBoolExp = {\n  _and?: InputMaybe<Array<EventsBoolExp>>;\n  _not?: InputMaybe<EventsBoolExp>;\n  _or?: InputMaybe<Array<EventsBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  creation_number?: InputMaybe<BigintComparisonExp>;\n  data?: InputMaybe<JsonbComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  indexed_type?: InputMaybe<StringComparisonExp>;\n  sequence_number?: InputMaybe<BigintComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"events\". */\nexport type EventsOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  creation_number?: InputMaybe<OrderBy>;\n  data?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  indexed_type?: InputMaybe<OrderBy>;\n  sequence_number?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"events\" */\nexport enum EventsSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  CreationNumber = \"creation_number\",\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  IndexedType = \"indexed_type\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** Streaming cursor of the table \"events\" */\nexport type EventsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: EventsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type EventsStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  indexed_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"fungible_asset_activities\" */\nexport type FungibleAssetActivities = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type: Scalars[\"String\"][\"output\"];\n  block_height: Scalars[\"bigint\"][\"output\"];\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index: Scalars[\"bigint\"][\"output\"];\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  is_frozen?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_gas_fee: Scalars[\"Boolean\"][\"output\"];\n  is_transaction_success: Scalars[\"Boolean\"][\"output\"];\n  /** An object relationship */\n  metadata?: Maybe<FungibleAssetMetadata>;\n  owner_address: Scalars[\"String\"][\"output\"];\n  /** An array relationship */\n  owner_aptos_names: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  owner_aptos_names_aggregate: CurrentAptosNamesAggregate;\n  storage_id: Scalars[\"String\"][\"output\"];\n  storage_refund_amount: Scalars[\"numeric\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesOwnerAptosNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesOwnerAptosNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** order by aggregate values of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAggregateOrderBy = {\n  avg?: InputMaybe<FungibleAssetActivitiesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<FungibleAssetActivitiesMaxOrderBy>;\n  min?: InputMaybe<FungibleAssetActivitiesMinOrderBy>;\n  stddev?: InputMaybe<FungibleAssetActivitiesStddevOrderBy>;\n  stddev_pop?: InputMaybe<FungibleAssetActivitiesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<FungibleAssetActivitiesStddevSampOrderBy>;\n  sum?: InputMaybe<FungibleAssetActivitiesSumOrderBy>;\n  var_pop?: InputMaybe<FungibleAssetActivitiesVarPopOrderBy>;\n  var_samp?: InputMaybe<FungibleAssetActivitiesVarSampOrderBy>;\n  variance?: InputMaybe<FungibleAssetActivitiesVarianceOrderBy>;\n};\n\n/** order by avg() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"fungible_asset_activities\". All fields are combined with a logical 'AND'. */\nexport type FungibleAssetActivitiesBoolExp = {\n  _and?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;\n  _not?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  _or?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;\n  is_frozen?: InputMaybe<BooleanComparisonExp>;\n  is_gas_fee?: InputMaybe<BooleanComparisonExp>;\n  is_transaction_success?: InputMaybe<BooleanComparisonExp>;\n  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  owner_aptos_names?: InputMaybe<CurrentAptosNamesBoolExp>;\n  owner_aptos_names_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  storage_refund_amount?: InputMaybe<NumericComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** order by max() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** order by min() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"fungible_asset_activities\". */\nexport type FungibleAssetActivitiesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  is_frozen?: InputMaybe<OrderBy>;\n  is_gas_fee?: InputMaybe<OrderBy>;\n  is_transaction_success?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  owner_aptos_names_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"fungible_asset_activities\" */\nexport enum FungibleAssetActivitiesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** order by stddev() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by stddev_pop() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by stddev_samp() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: FungibleAssetActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type FungibleAssetActivitiesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** order by sum() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by var_pop() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by var_samp() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** order by variance() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadata = {\n  asset_type: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  decimals: Scalars[\"Int\"][\"output\"];\n  icon_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  project_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  symbol: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"fungible_asset_metadata\". All fields are combined with a logical 'AND'. */\nexport type FungibleAssetMetadataBoolExp = {\n  _and?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;\n  _not?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  _or?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  decimals?: InputMaybe<IntComparisonExp>;\n  icon_uri?: InputMaybe<StringComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  project_uri?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_handle_v1?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_key_v1?: InputMaybe<StringComparisonExp>;\n  symbol?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"fungible_asset_metadata\". */\nexport type FungibleAssetMetadataOrderBy = {\n  asset_type?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  icon_uri?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  project_uri?: InputMaybe<OrderBy>;\n  supply_aggregator_table_handle_v1?: InputMaybe<OrderBy>;\n  supply_aggregator_table_key_v1?: InputMaybe<OrderBy>;\n  symbol?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"fungible_asset_metadata\" */\nexport enum FungibleAssetMetadataSelectColumn {\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  IconUri = \"icon_uri\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  ProjectUri = \"project_uri\",\n  /** column name */\n  SupplyAggregatorTableHandleV1 = \"supply_aggregator_table_handle_v1\",\n  /** column name */\n  SupplyAggregatorTableKeyV1 = \"supply_aggregator_table_key_v1\",\n  /** column name */\n  Symbol = \"symbol\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** Streaming cursor of the table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: FungibleAssetMetadataStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type FungibleAssetMetadataStreamCursorValueInput = {\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  icon_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  project_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"indexer_status\" */\nexport type IndexerStatus = {\n  db: Scalars[\"String\"][\"output\"];\n  is_indexer_up: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"indexer_status\". All fields are combined with a logical 'AND'. */\nexport type IndexerStatusBoolExp = {\n  _and?: InputMaybe<Array<IndexerStatusBoolExp>>;\n  _not?: InputMaybe<IndexerStatusBoolExp>;\n  _or?: InputMaybe<Array<IndexerStatusBoolExp>>;\n  db?: InputMaybe<StringComparisonExp>;\n  is_indexer_up?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"indexer_status\". */\nexport type IndexerStatusOrderBy = {\n  db?: InputMaybe<OrderBy>;\n  is_indexer_up?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"indexer_status\" */\nexport enum IndexerStatusSelectColumn {\n  /** column name */\n  Db = \"db\",\n  /** column name */\n  IsIndexerUp = \"is_indexer_up\",\n}\n\n/** Streaming cursor of the table \"indexer_status\" */\nexport type IndexerStatusStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: IndexerStatusStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type IndexerStatusStreamCursorValueInput = {\n  db?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_indexer_up?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\nexport type JsonbCastExp = {\n  String?: InputMaybe<StringComparisonExp>;\n};\n\n/** Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'. */\nexport type JsonbComparisonExp = {\n  _cast?: InputMaybe<JsonbCastExp>;\n  /** is the column contained in the given json value */\n  _contained_in?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  /** does the column contain the given json value at the top level */\n  _contains?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _eq?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  /** does the string exist as a top-level key in the column */\n  _has_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** do all of these strings exist as top-level keys in the column */\n  _has_keys_all?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  /** do any of these strings exist as top-level keys in the column */\n  _has_keys_any?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  _in?: InputMaybe<Array<Scalars[\"jsonb\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"jsonb\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"ledger_infos\" */\nexport type LedgerInfos = {\n  chain_id: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"ledger_infos\". All fields are combined with a logical 'AND'. */\nexport type LedgerInfosBoolExp = {\n  _and?: InputMaybe<Array<LedgerInfosBoolExp>>;\n  _not?: InputMaybe<LedgerInfosBoolExp>;\n  _or?: InputMaybe<Array<LedgerInfosBoolExp>>;\n  chain_id?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"ledger_infos\". */\nexport type LedgerInfosOrderBy = {\n  chain_id?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"ledger_infos\" */\nexport enum LedgerInfosSelectColumn {\n  /** column name */\n  ChainId = \"chain_id\",\n}\n\n/** Streaming cursor of the table \"ledger_infos\" */\nexport type LedgerInfosStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: LedgerInfosStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type LedgerInfosStreamCursorValueInput = {\n  chain_id?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"move_resources\" */\nexport type MoveResources = {\n  address: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"move_resources\" */\nexport type MoveResourcesAggregate = {\n  aggregate?: Maybe<MoveResourcesAggregateFields>;\n  nodes: Array<MoveResources>;\n};\n\n/** aggregate fields of \"move_resources\" */\nexport type MoveResourcesAggregateFields = {\n  avg?: Maybe<MoveResourcesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<MoveResourcesMaxFields>;\n  min?: Maybe<MoveResourcesMinFields>;\n  stddev?: Maybe<MoveResourcesStddevFields>;\n  stddev_pop?: Maybe<MoveResourcesStddevPopFields>;\n  stddev_samp?: Maybe<MoveResourcesStddevSampFields>;\n  sum?: Maybe<MoveResourcesSumFields>;\n  var_pop?: Maybe<MoveResourcesVarPopFields>;\n  var_samp?: Maybe<MoveResourcesVarSampFields>;\n  variance?: Maybe<MoveResourcesVarianceFields>;\n};\n\n/** aggregate fields of \"move_resources\" */\nexport type MoveResourcesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type MoveResourcesAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"move_resources\". All fields are combined with a logical 'AND'. */\nexport type MoveResourcesBoolExp = {\n  _and?: InputMaybe<Array<MoveResourcesBoolExp>>;\n  _not?: InputMaybe<MoveResourcesBoolExp>;\n  _or?: InputMaybe<Array<MoveResourcesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type MoveResourcesMaxFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type MoveResourcesMinFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"move_resources\". */\nexport type MoveResourcesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"move_resources\" */\nexport enum MoveResourcesSelectColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type MoveResourcesStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type MoveResourcesStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type MoveResourcesStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"move_resources\" */\nexport type MoveResourcesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: MoveResourcesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type MoveResourcesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type MoveResourcesSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type MoveResourcesVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type MoveResourcesVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type MoveResourcesVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_auctions\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceAuctions = {\n  buy_it_now_price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  contract_address: Scalars[\"String\"][\"output\"];\n  current_bid_price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  current_bidder?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  expiration_time: Scalars[\"numeric\"][\"output\"];\n  fee_schedule_id: Scalars[\"String\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamptz\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  listing_id: Scalars[\"String\"][\"output\"];\n  marketplace: Scalars[\"String\"][\"output\"];\n  seller: Scalars[\"String\"][\"output\"];\n  starting_bid_price: Scalars[\"numeric\"][\"output\"];\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_auctions\". All fields are combined with a logical 'AND'. */\nexport type NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp = {\n  _and?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp>>;\n  _not?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp>;\n  _or?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp>>;\n  buy_it_now_price?: InputMaybe<NumericComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  contract_address?: InputMaybe<StringComparisonExp>;\n  current_bid_price?: InputMaybe<NumericComparisonExp>;\n  current_bidder?: InputMaybe<StringComparisonExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  expiration_time?: InputMaybe<NumericComparisonExp>;\n  fee_schedule_id?: InputMaybe<StringComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  listing_id?: InputMaybe<StringComparisonExp>;\n  marketplace?: InputMaybe<StringComparisonExp>;\n  seller?: InputMaybe<StringComparisonExp>;\n  starting_bid_price?: InputMaybe<NumericComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_auctions\". */\nexport type NftMarketplaceV2CurrentNftMarketplaceAuctionsOrderBy = {\n  buy_it_now_price?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  contract_address?: InputMaybe<OrderBy>;\n  current_bid_price?: InputMaybe<OrderBy>;\n  current_bidder?: InputMaybe<OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  expiration_time?: InputMaybe<OrderBy>;\n  fee_schedule_id?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  listing_id?: InputMaybe<OrderBy>;\n  marketplace?: InputMaybe<OrderBy>;\n  seller?: InputMaybe<OrderBy>;\n  starting_bid_price?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"nft_marketplace_v2.current_nft_marketplace_auctions\" */\nexport enum NftMarketplaceV2CurrentNftMarketplaceAuctionsSelectColumn {\n  /** column name */\n  BuyItNowPrice = \"buy_it_now_price\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  ContractAddress = \"contract_address\",\n  /** column name */\n  CurrentBidPrice = \"current_bid_price\",\n  /** column name */\n  CurrentBidder = \"current_bidder\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  ExpirationTime = \"expiration_time\",\n  /** column name */\n  FeeScheduleId = \"fee_schedule_id\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ListingId = \"listing_id\",\n  /** column name */\n  Marketplace = \"marketplace\",\n  /** column name */\n  Seller = \"seller\",\n  /** column name */\n  StartingBidPrice = \"starting_bid_price\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_auctions\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceAuctionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMarketplaceV2CurrentNftMarketplaceAuctionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMarketplaceV2CurrentNftMarketplaceAuctionsStreamCursorValueInput = {\n  buy_it_now_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_bid_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  current_bidder?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_time?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  fee_schedule_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  listing_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  marketplace?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  seller?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  starting_bid_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceCollectionOffers = {\n  buyer: Scalars[\"String\"][\"output\"];\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_offer_id: Scalars[\"String\"][\"output\"];\n  contract_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection_v2?: Maybe<CurrentCollectionsV2>;\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  expiration_time: Scalars[\"numeric\"][\"output\"];\n  fee_schedule_id: Scalars[\"String\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  item_price: Scalars[\"numeric\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamptz\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  marketplace: Scalars[\"String\"][\"output\"];\n  remaining_token_amount: Scalars[\"numeric\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_collection_offers\". All fields are combined with a logical 'AND'. */\nexport type NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp = {\n  _and?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp>>;\n  _not?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp>;\n  _or?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp>>;\n  buyer?: InputMaybe<StringComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_offer_id?: InputMaybe<StringComparisonExp>;\n  contract_address?: InputMaybe<StringComparisonExp>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  expiration_time?: InputMaybe<NumericComparisonExp>;\n  fee_schedule_id?: InputMaybe<StringComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  item_price?: InputMaybe<NumericComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  marketplace?: InputMaybe<StringComparisonExp>;\n  remaining_token_amount?: InputMaybe<NumericComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_collection_offers\". */\nexport type NftMarketplaceV2CurrentNftMarketplaceCollectionOffersOrderBy = {\n  buyer?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  collection_offer_id?: InputMaybe<OrderBy>;\n  contract_address?: InputMaybe<OrderBy>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  expiration_time?: InputMaybe<OrderBy>;\n  fee_schedule_id?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  item_price?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  marketplace?: InputMaybe<OrderBy>;\n  remaining_token_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" */\nexport enum NftMarketplaceV2CurrentNftMarketplaceCollectionOffersSelectColumn {\n  /** column name */\n  Buyer = \"buyer\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionOfferId = \"collection_offer_id\",\n  /** column name */\n  ContractAddress = \"contract_address\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  ExpirationTime = \"expiration_time\",\n  /** column name */\n  FeeScheduleId = \"fee_schedule_id\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  ItemPrice = \"item_price\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Marketplace = \"marketplace\",\n  /** column name */\n  RemainingTokenAmount = \"remaining_token_amount\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_collection_offers\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceCollectionOffersStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMarketplaceV2CurrentNftMarketplaceCollectionOffersStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMarketplaceV2CurrentNftMarketplaceCollectionOffersStreamCursorValueInput = {\n  buyer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_offer_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_time?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  fee_schedule_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  item_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  marketplace?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  remaining_token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_listings\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceListings = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  contract_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  fee_schedule_id: Scalars[\"String\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamptz\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  listing_id: Scalars[\"String\"][\"output\"];\n  marketplace: Scalars[\"String\"][\"output\"];\n  price: Scalars[\"numeric\"][\"output\"];\n  seller: Scalars[\"String\"][\"output\"];\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"nft_marketplace_v2.current_nft_marketplace_listings\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsAggregate = {\n  aggregate?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsAggregateFields>;\n  nodes: Array<NftMarketplaceV2CurrentNftMarketplaceListings>;\n};\n\n/** aggregate fields of \"nft_marketplace_v2.current_nft_marketplace_listings\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsAggregateFields = {\n  avg?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsMaxFields>;\n  min?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsMinFields>;\n  stddev?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsStddevFields>;\n  stddev_pop?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsStddevPopFields>;\n  stddev_samp?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsStddevSampFields>;\n  sum?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsSumFields>;\n  var_pop?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsVarPopFields>;\n  var_samp?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsVarSampFields>;\n  variance?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListingsVarianceFields>;\n};\n\n/** aggregate fields of \"nft_marketplace_v2.current_nft_marketplace_listings\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_listings\". All fields are combined with a logical 'AND'. */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp = {\n  _and?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>>;\n  _not?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>;\n  _or?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  contract_address?: InputMaybe<StringComparisonExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  fee_schedule_id?: InputMaybe<StringComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  listing_id?: InputMaybe<StringComparisonExp>;\n  marketplace?: InputMaybe<StringComparisonExp>;\n  price?: InputMaybe<NumericComparisonExp>;\n  seller?: InputMaybe<StringComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsMaxFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  contract_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  fee_schedule_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamptz\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  listing_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  marketplace?: Maybe<Scalars[\"String\"][\"output\"]>;\n  price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  seller?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsMinFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  contract_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  fee_schedule_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamptz\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  listing_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  marketplace?: Maybe<Scalars[\"String\"][\"output\"]>;\n  price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  seller?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_listings\". */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsOrderBy = {\n  coin_type?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  contract_address?: InputMaybe<OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  fee_schedule_id?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  listing_id?: InputMaybe<OrderBy>;\n  marketplace?: InputMaybe<OrderBy>;\n  price?: InputMaybe<OrderBy>;\n  seller?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"nft_marketplace_v2.current_nft_marketplace_listings\" */\nexport enum NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  ContractAddress = \"contract_address\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  FeeScheduleId = \"fee_schedule_id\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ListingId = \"listing_id\",\n  /** column name */\n  Marketplace = \"marketplace\",\n  /** column name */\n  Price = \"price\",\n  /** column name */\n  Seller = \"seller\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** aggregate stddev on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_listings\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMarketplaceV2CurrentNftMarketplaceListingsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsStreamCursorValueInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  fee_schedule_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  listing_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  marketplace?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  seller?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type NftMarketplaceV2CurrentNftMarketplaceListingsVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_token_offers\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceTokenOffers = {\n  buyer: Scalars[\"String\"][\"output\"];\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  contract_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  expiration_time: Scalars[\"numeric\"][\"output\"];\n  fee_schedule_id: Scalars[\"String\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamptz\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  marketplace: Scalars[\"String\"][\"output\"];\n  offer_id: Scalars[\"String\"][\"output\"];\n  price: Scalars[\"numeric\"][\"output\"];\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_token_offers\". All fields are combined with a logical 'AND'. */\nexport type NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp = {\n  _and?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp>>;\n  _not?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp>;\n  _or?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp>>;\n  buyer?: InputMaybe<StringComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  contract_address?: InputMaybe<StringComparisonExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  expiration_time?: InputMaybe<NumericComparisonExp>;\n  fee_schedule_id?: InputMaybe<StringComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  marketplace?: InputMaybe<StringComparisonExp>;\n  offer_id?: InputMaybe<StringComparisonExp>;\n  price?: InputMaybe<NumericComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_token_offers\". */\nexport type NftMarketplaceV2CurrentNftMarketplaceTokenOffersOrderBy = {\n  buyer?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  contract_address?: InputMaybe<OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  expiration_time?: InputMaybe<OrderBy>;\n  fee_schedule_id?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  marketplace?: InputMaybe<OrderBy>;\n  offer_id?: InputMaybe<OrderBy>;\n  price?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"nft_marketplace_v2.current_nft_marketplace_token_offers\" */\nexport enum NftMarketplaceV2CurrentNftMarketplaceTokenOffersSelectColumn {\n  /** column name */\n  Buyer = \"buyer\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  ContractAddress = \"contract_address\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  ExpirationTime = \"expiration_time\",\n  /** column name */\n  FeeScheduleId = \"fee_schedule_id\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Marketplace = \"marketplace\",\n  /** column name */\n  OfferId = \"offer_id\",\n  /** column name */\n  Price = \"price\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_token_offers\" */\nexport type NftMarketplaceV2CurrentNftMarketplaceTokenOffersStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMarketplaceV2CurrentNftMarketplaceTokenOffersStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMarketplaceV2CurrentNftMarketplaceTokenOffersStreamCursorValueInput = {\n  buyer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_time?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  fee_schedule_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  marketplace?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  offer_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"nft_marketplace_v2.nft_marketplace_activities\" */\nexport type NftMarketplaceV2NftMarketplaceActivities = {\n  buyer?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  contract_address: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  event_type: Scalars[\"String\"][\"output\"];\n  fee_schedule_id: Scalars[\"String\"][\"output\"];\n  marketplace: Scalars[\"String\"][\"output\"];\n  offer_or_listing_id: Scalars[\"String\"][\"output\"];\n  price: Scalars[\"numeric\"][\"output\"];\n  property_version?: Maybe<Scalars[\"String\"][\"output\"]>;\n  seller?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamptz\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"nft_marketplace_v2.nft_marketplace_activities\". All fields are combined with a logical 'AND'. */\nexport type NftMarketplaceV2NftMarketplaceActivitiesBoolExp = {\n  _and?: InputMaybe<Array<NftMarketplaceV2NftMarketplaceActivitiesBoolExp>>;\n  _not?: InputMaybe<NftMarketplaceV2NftMarketplaceActivitiesBoolExp>;\n  _or?: InputMaybe<Array<NftMarketplaceV2NftMarketplaceActivitiesBoolExp>>;\n  buyer?: InputMaybe<StringComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  contract_address?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_type?: InputMaybe<StringComparisonExp>;\n  fee_schedule_id?: InputMaybe<StringComparisonExp>;\n  marketplace?: InputMaybe<StringComparisonExp>;\n  offer_or_listing_id?: InputMaybe<StringComparisonExp>;\n  price?: InputMaybe<NumericComparisonExp>;\n  property_version?: InputMaybe<StringComparisonExp>;\n  seller?: InputMaybe<StringComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"nft_marketplace_v2.nft_marketplace_activities\". */\nexport type NftMarketplaceV2NftMarketplaceActivitiesOrderBy = {\n  buyer?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  contract_address?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  fee_schedule_id?: InputMaybe<OrderBy>;\n  marketplace?: InputMaybe<OrderBy>;\n  offer_or_listing_id?: InputMaybe<OrderBy>;\n  price?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  seller?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"nft_marketplace_v2.nft_marketplace_activities\" */\nexport enum NftMarketplaceV2NftMarketplaceActivitiesSelectColumn {\n  /** column name */\n  Buyer = \"buyer\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  ContractAddress = \"contract_address\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventType = \"event_type\",\n  /** column name */\n  FeeScheduleId = \"fee_schedule_id\",\n  /** column name */\n  Marketplace = \"marketplace\",\n  /** column name */\n  OfferOrListingId = \"offer_or_listing_id\",\n  /** column name */\n  Price = \"price\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  Seller = \"seller\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** Streaming cursor of the table \"nft_marketplace_v2_nft_marketplace_activities\" */\nexport type NftMarketplaceV2NftMarketplaceActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMarketplaceV2NftMarketplaceActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMarketplaceV2NftMarketplaceActivitiesStreamCursorValueInput = {\n  buyer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  fee_schedule_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  marketplace?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  offer_or_listing_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  seller?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUris = {\n  animation_optimizer_retry_count: Scalars[\"Int\"][\"output\"];\n  asset_uri: Scalars[\"String\"][\"output\"];\n  cdn_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_json_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  image_optimizer_retry_count: Scalars[\"Int\"][\"output\"];\n  json_parser_retry_count: Scalars[\"Int\"][\"output\"];\n  raw_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  raw_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"nft_metadata_crawler.parsed_asset_uris\". All fields are combined with a logical 'AND'. */\nexport type NftMetadataCrawlerParsedAssetUrisBoolExp = {\n  _and?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;\n  _not?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n  _or?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;\n  animation_optimizer_retry_count?: InputMaybe<IntComparisonExp>;\n  asset_uri?: InputMaybe<StringComparisonExp>;\n  cdn_animation_uri?: InputMaybe<StringComparisonExp>;\n  cdn_image_uri?: InputMaybe<StringComparisonExp>;\n  cdn_json_uri?: InputMaybe<StringComparisonExp>;\n  image_optimizer_retry_count?: InputMaybe<IntComparisonExp>;\n  json_parser_retry_count?: InputMaybe<IntComparisonExp>;\n  raw_animation_uri?: InputMaybe<StringComparisonExp>;\n  raw_image_uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"nft_metadata_crawler.parsed_asset_uris\". */\nexport type NftMetadataCrawlerParsedAssetUrisOrderBy = {\n  animation_optimizer_retry_count?: InputMaybe<OrderBy>;\n  asset_uri?: InputMaybe<OrderBy>;\n  cdn_animation_uri?: InputMaybe<OrderBy>;\n  cdn_image_uri?: InputMaybe<OrderBy>;\n  cdn_json_uri?: InputMaybe<OrderBy>;\n  image_optimizer_retry_count?: InputMaybe<OrderBy>;\n  json_parser_retry_count?: InputMaybe<OrderBy>;\n  raw_animation_uri?: InputMaybe<OrderBy>;\n  raw_image_uri?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport enum NftMetadataCrawlerParsedAssetUrisSelectColumn {\n  /** column name */\n  AnimationOptimizerRetryCount = \"animation_optimizer_retry_count\",\n  /** column name */\n  AssetUri = \"asset_uri\",\n  /** column name */\n  CdnAnimationUri = \"cdn_animation_uri\",\n  /** column name */\n  CdnImageUri = \"cdn_image_uri\",\n  /** column name */\n  CdnJsonUri = \"cdn_json_uri\",\n  /** column name */\n  ImageOptimizerRetryCount = \"image_optimizer_retry_count\",\n  /** column name */\n  JsonParserRetryCount = \"json_parser_retry_count\",\n  /** column name */\n  RawAnimationUri = \"raw_animation_uri\",\n  /** column name */\n  RawImageUri = \"raw_image_uri\",\n}\n\n/** Streaming cursor of the table \"nft_metadata_crawler_parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput = {\n  animation_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  asset_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_json_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  image_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  json_parser_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  raw_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  raw_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPool = {\n  num_active_delegator?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"num_active_delegator_per_pool\". All fields are combined with a logical 'AND'. */\nexport type NumActiveDelegatorPerPoolBoolExp = {\n  _and?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;\n  _not?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n  _or?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;\n  num_active_delegator?: InputMaybe<BigintComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"num_active_delegator_per_pool\". */\nexport type NumActiveDelegatorPerPoolOrderBy = {\n  num_active_delegator?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"num_active_delegator_per_pool\" */\nexport enum NumActiveDelegatorPerPoolSelectColumn {\n  /** column name */\n  NumActiveDelegator = \"num_active_delegator\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n}\n\n/** Streaming cursor of the table \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPoolStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NumActiveDelegatorPerPoolStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NumActiveDelegatorPerPoolStreamCursorValueInput = {\n  num_active_delegator?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'. */\nexport type NumericComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"numeric\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"numeric\"][\"input\"]>>;\n};\n\n/** column ordering options */\nexport enum OrderBy {\n  /** in ascending order, nulls last */\n  Asc = \"asc\",\n  /** in ascending order, nulls first */\n  AscNullsFirst = \"asc_nulls_first\",\n  /** in ascending order, nulls last */\n  AscNullsLast = \"asc_nulls_last\",\n  /** in descending order, nulls first */\n  Desc = \"desc\",\n  /** in descending order, nulls first */\n  DescNullsFirst = \"desc_nulls_first\",\n  /** in descending order, nulls last */\n  DescNullsLast = \"desc_nulls_last\",\n}\n\n/** columns and relationships of \"processor_status\" */\nexport type ProcessorStatus = {\n  last_success_version: Scalars[\"bigint\"][\"output\"];\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated: Scalars[\"timestamp\"][\"output\"];\n  processor: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"processor_status\". All fields are combined with a logical 'AND'. */\nexport type ProcessorStatusBoolExp = {\n  _and?: InputMaybe<Array<ProcessorStatusBoolExp>>;\n  _not?: InputMaybe<ProcessorStatusBoolExp>;\n  _or?: InputMaybe<Array<ProcessorStatusBoolExp>>;\n  last_success_version?: InputMaybe<BigintComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_updated?: InputMaybe<TimestampComparisonExp>;\n  processor?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"processor_status\". */\nexport type ProcessorStatusOrderBy = {\n  last_success_version?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_updated?: InputMaybe<OrderBy>;\n  processor?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"processor_status\" */\nexport enum ProcessorStatusSelectColumn {\n  /** column name */\n  LastSuccessVersion = \"last_success_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n  /** column name */\n  Processor = \"processor\",\n}\n\n/** Streaming cursor of the table \"processor_status\" */\nexport type ProcessorStatusStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: ProcessorStatusStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProcessorStatusStreamCursorValueInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"proposal_votes\" */\nexport type ProposalVotes = {\n  num_votes: Scalars[\"numeric\"][\"output\"];\n  proposal_id: Scalars[\"bigint\"][\"output\"];\n  should_pass: Scalars[\"Boolean\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  voter_address: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"proposal_votes\" */\nexport type ProposalVotesAggregate = {\n  aggregate?: Maybe<ProposalVotesAggregateFields>;\n  nodes: Array<ProposalVotes>;\n};\n\n/** aggregate fields of \"proposal_votes\" */\nexport type ProposalVotesAggregateFields = {\n  avg?: Maybe<ProposalVotesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<ProposalVotesMaxFields>;\n  min?: Maybe<ProposalVotesMinFields>;\n  stddev?: Maybe<ProposalVotesStddevFields>;\n  stddev_pop?: Maybe<ProposalVotesStddevPopFields>;\n  stddev_samp?: Maybe<ProposalVotesStddevSampFields>;\n  sum?: Maybe<ProposalVotesSumFields>;\n  var_pop?: Maybe<ProposalVotesVarPopFields>;\n  var_samp?: Maybe<ProposalVotesVarSampFields>;\n  variance?: Maybe<ProposalVotesVarianceFields>;\n};\n\n/** aggregate fields of \"proposal_votes\" */\nexport type ProposalVotesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type ProposalVotesAvgFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"proposal_votes\". All fields are combined with a logical 'AND'. */\nexport type ProposalVotesBoolExp = {\n  _and?: InputMaybe<Array<ProposalVotesBoolExp>>;\n  _not?: InputMaybe<ProposalVotesBoolExp>;\n  _or?: InputMaybe<Array<ProposalVotesBoolExp>>;\n  num_votes?: InputMaybe<NumericComparisonExp>;\n  proposal_id?: InputMaybe<BigintComparisonExp>;\n  should_pass?: InputMaybe<BooleanComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  voter_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type ProposalVotesMaxFields = {\n  num_votes?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  voter_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type ProposalVotesMinFields = {\n  num_votes?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  voter_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"proposal_votes\". */\nexport type ProposalVotesOrderBy = {\n  num_votes?: InputMaybe<OrderBy>;\n  proposal_id?: InputMaybe<OrderBy>;\n  should_pass?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  voter_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"proposal_votes\" */\nexport enum ProposalVotesSelectColumn {\n  /** column name */\n  NumVotes = \"num_votes\",\n  /** column name */\n  ProposalId = \"proposal_id\",\n  /** column name */\n  ShouldPass = \"should_pass\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  VoterAddress = \"voter_address\",\n}\n\n/** aggregate stddev on columns */\nexport type ProposalVotesStddevFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type ProposalVotesStddevPopFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type ProposalVotesStddevSampFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"proposal_votes\" */\nexport type ProposalVotesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: ProposalVotesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProposalVotesStreamCursorValueInput = {\n  num_votes?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  proposal_id?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  should_pass?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type ProposalVotesSumFields = {\n  num_votes?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type ProposalVotesVarPopFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type ProposalVotesVarSampFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type ProposalVotesVarianceFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\nexport type QueryRoot = {\n  /** fetch data from the table: \"account_transactions\" */\n  account_transactions: Array<AccountTransactions>;\n  /** fetch aggregated fields from the table: \"account_transactions\" */\n  account_transactions_aggregate: AccountTransactionsAggregate;\n  /** fetch data from the table: \"account_transactions\" using primary key columns */\n  account_transactions_by_pk?: Maybe<AccountTransactions>;\n  /** fetch data from the table: \"address_events_summary\" */\n  address_events_summary: Array<AddressEventsSummary>;\n  /** fetch data from the table: \"address_version_from_events\" */\n  address_version_from_events: Array<AddressVersionFromEvents>;\n  /** fetch aggregated fields from the table: \"address_version_from_events\" */\n  address_version_from_events_aggregate: AddressVersionFromEventsAggregate;\n  /** fetch data from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources: Array<AddressVersionFromMoveResources>;\n  /** fetch aggregated fields from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;\n  /** fetch data from the table: \"block_metadata_transactions\" */\n  block_metadata_transactions: Array<BlockMetadataTransactions>;\n  /** fetch data from the table: \"block_metadata_transactions\" using primary key columns */\n  block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;\n  /** An array relationship */\n  coin_activities: Array<CoinActivities>;\n  /** An aggregate relationship */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** fetch data from the table: \"coin_activities\" using primary key columns */\n  coin_activities_by_pk?: Maybe<CoinActivities>;\n  /** fetch data from the table: \"coin_balances\" */\n  coin_balances: Array<CoinBalances>;\n  /** fetch data from the table: \"coin_balances\" using primary key columns */\n  coin_balances_by_pk?: Maybe<CoinBalances>;\n  /** fetch data from the table: \"coin_infos\" */\n  coin_infos: Array<CoinInfos>;\n  /** fetch data from the table: \"coin_infos\" using primary key columns */\n  coin_infos_by_pk?: Maybe<CoinInfos>;\n  /** fetch data from the table: \"coin_supply\" */\n  coin_supply: Array<CoinSupply>;\n  /** fetch data from the table: \"coin_supply\" using primary key columns */\n  coin_supply_by_pk?: Maybe<CoinSupply>;\n  /** fetch data from the table: \"collection_datas\" */\n  collection_datas: Array<CollectionDatas>;\n  /** fetch data from the table: \"collection_datas\" using primary key columns */\n  collection_datas_by_pk?: Maybe<CollectionDatas>;\n  /** fetch data from the table: \"current_ans_lookup\" */\n  current_ans_lookup: Array<CurrentAnsLookup>;\n  /** fetch data from the table: \"current_ans_lookup\" using primary key columns */\n  current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;\n  /** fetch data from the table: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2: Array<CurrentAnsLookupV2>;\n  /** fetch data from the table: \"current_ans_lookup_v2\" using primary key columns */\n  current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;\n  /** fetch data from the table: \"current_aptos_names\" */\n  current_aptos_names: Array<CurrentAptosNames>;\n  /** fetch aggregated fields from the table: \"current_aptos_names\" */\n  current_aptos_names_aggregate: CurrentAptosNamesAggregate;\n  /** fetch data from the table: \"current_coin_balances\" */\n  current_coin_balances: Array<CurrentCoinBalances>;\n  /** fetch data from the table: \"current_coin_balances\" using primary key columns */\n  current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;\n  /** fetch data from the table: \"current_collection_datas\" */\n  current_collection_datas: Array<CurrentCollectionDatas>;\n  /** fetch data from the table: \"current_collection_datas\" using primary key columns */\n  current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;\n  /** fetch data from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;\n  /** fetch aggregated fields from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;\n  /** fetch data from the table: \"current_collections_v2\" */\n  current_collections_v2: Array<CurrentCollectionsV2>;\n  /** fetch data from the table: \"current_collections_v2\" using primary key columns */\n  current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" using primary key columns */\n  current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"current_delegated_voter\" */\n  current_delegated_voter: Array<CurrentDelegatedVoter>;\n  /** fetch data from the table: \"current_delegated_voter\" using primary key columns */\n  current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;\n  /** fetch data from the table: \"current_delegator_balances\" */\n  current_delegator_balances: Array<CurrentDelegatorBalances>;\n  /** fetch data from the table: \"current_delegator_balances\" using primary key columns */\n  current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;\n  /** fetch data from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;\n  /** fetch aggregated fields from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;\n  /** fetch data from the table: \"current_fungible_asset_balances\" using primary key columns */\n  current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;\n  /** fetch data from the table: \"current_objects\" */\n  current_objects: Array<CurrentObjects>;\n  /** fetch data from the table: \"current_objects\" using primary key columns */\n  current_objects_by_pk?: Maybe<CurrentObjects>;\n  /** fetch data from the table: \"current_staking_pool_voter\" */\n  current_staking_pool_voter: Array<CurrentStakingPoolVoter>;\n  /** fetch data from the table: \"current_staking_pool_voter\" using primary key columns */\n  current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;\n  /** fetch data from the table: \"current_table_items\" */\n  current_table_items: Array<CurrentTableItems>;\n  /** fetch data from the table: \"current_table_items\" using primary key columns */\n  current_table_items_by_pk?: Maybe<CurrentTableItems>;\n  /** fetch data from the table: \"current_token_datas\" */\n  current_token_datas: Array<CurrentTokenDatas>;\n  /** fetch data from the table: \"current_token_datas\" using primary key columns */\n  current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;\n  /** fetch data from the table: \"current_token_datas_v2\" */\n  current_token_datas_v2: Array<CurrentTokenDatasV2>;\n  /** fetch data from the table: \"current_token_datas_v2\" using primary key columns */\n  current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;\n  /** fetch data from the table: \"current_token_ownerships\" */\n  current_token_ownerships: Array<CurrentTokenOwnerships>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships\" */\n  current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;\n  /** fetch data from the table: \"current_token_ownerships\" using primary key columns */\n  current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;\n  /** fetch data from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  /** fetch data from the table: \"current_token_ownerships_v2\" using primary key columns */\n  current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;\n  /** fetch data from the table: \"current_token_pending_claims\" */\n  current_token_pending_claims: Array<CurrentTokenPendingClaims>;\n  /** fetch data from the table: \"current_token_pending_claims\" using primary key columns */\n  current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;\n  /** An array relationship */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** fetch data from the table: \"delegated_staking_activities\" using primary key columns */\n  delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;\n  /** fetch aggregated fields from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" using primary key columns */\n  delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"delegated_staking_pools\" */\n  delegated_staking_pools: Array<DelegatedStakingPools>;\n  /** fetch data from the table: \"delegated_staking_pools\" using primary key columns */\n  delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;\n  /** fetch data from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool: Array<DelegatorDistinctPool>;\n  /** fetch aggregated fields from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;\n  /** fetch data from the table: \"events\" */\n  events: Array<Events>;\n  /** fetch data from the table: \"events\" using primary key columns */\n  events_by_pk?: Maybe<Events>;\n  /** An array relationship */\n  fungible_asset_activities: Array<FungibleAssetActivities>;\n  /** fetch data from the table: \"fungible_asset_activities\" using primary key columns */\n  fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;\n  /** fetch data from the table: \"fungible_asset_metadata\" */\n  fungible_asset_metadata: Array<FungibleAssetMetadata>;\n  /** fetch data from the table: \"fungible_asset_metadata\" using primary key columns */\n  fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;\n  /** fetch data from the table: \"indexer_status\" */\n  indexer_status: Array<IndexerStatus>;\n  /** fetch data from the table: \"indexer_status\" using primary key columns */\n  indexer_status_by_pk?: Maybe<IndexerStatus>;\n  /** fetch data from the table: \"ledger_infos\" */\n  ledger_infos: Array<LedgerInfos>;\n  /** fetch data from the table: \"ledger_infos\" using primary key columns */\n  ledger_infos_by_pk?: Maybe<LedgerInfos>;\n  /** fetch data from the table: \"move_resources\" */\n  move_resources: Array<MoveResources>;\n  /** fetch aggregated fields from the table: \"move_resources\" */\n  move_resources_aggregate: MoveResourcesAggregate;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\" */\n  nft_marketplace_v2_current_nft_marketplace_auctions: Array<NftMarketplaceV2CurrentNftMarketplaceAuctions>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_auctions_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceAuctions>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" */\n  nft_marketplace_v2_current_nft_marketplace_collection_offers: Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_collection_offers_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" */\n  nft_marketplace_v2_current_nft_marketplace_listings: Array<NftMarketplaceV2CurrentNftMarketplaceListings>;\n  /** fetch aggregated fields from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" */\n  nft_marketplace_v2_current_nft_marketplace_listings_aggregate: NftMarketplaceV2CurrentNftMarketplaceListingsAggregate;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_listings_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListings>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" */\n  nft_marketplace_v2_current_nft_marketplace_token_offers: Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_token_offers_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\" */\n  nft_marketplace_v2_nft_marketplace_activities: Array<NftMarketplaceV2NftMarketplaceActivities>;\n  /** fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\" using primary key columns */\n  nft_marketplace_v2_nft_marketplace_activities_by_pk?: Maybe<NftMarketplaceV2NftMarketplaceActivities>;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" using primary key columns */\n  nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;\n  /** fetch data from the table: \"processor_status\" */\n  processor_status: Array<ProcessorStatus>;\n  /** fetch data from the table: \"processor_status\" using primary key columns */\n  processor_status_by_pk?: Maybe<ProcessorStatus>;\n  /** fetch data from the table: \"proposal_votes\" */\n  proposal_votes: Array<ProposalVotes>;\n  /** fetch aggregated fields from the table: \"proposal_votes\" */\n  proposal_votes_aggregate: ProposalVotesAggregate;\n  /** fetch data from the table: \"proposal_votes\" using primary key columns */\n  proposal_votes_by_pk?: Maybe<ProposalVotes>;\n  /** fetch data from the table: \"signatures\" */\n  signatures: Array<Signatures>;\n  /** fetch data from the table: \"signatures\" using primary key columns */\n  signatures_by_pk?: Maybe<Signatures>;\n  /** fetch data from the table: \"table_items\" */\n  table_items: Array<TableItems>;\n  /** fetch data from the table: \"table_items\" using primary key columns */\n  table_items_by_pk?: Maybe<TableItems>;\n  /** fetch data from the table: \"table_metadatas\" */\n  table_metadatas: Array<TableMetadatas>;\n  /** fetch data from the table: \"table_metadatas\" using primary key columns */\n  table_metadatas_by_pk?: Maybe<TableMetadatas>;\n  /** An array relationship */\n  token_activities: Array<TokenActivities>;\n  /** An aggregate relationship */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** fetch data from the table: \"token_activities\" using primary key columns */\n  token_activities_by_pk?: Maybe<TokenActivities>;\n  /** An array relationship */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** An aggregate relationship */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  /** fetch data from the table: \"token_activities_v2\" using primary key columns */\n  token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;\n  /** fetch data from the table: \"token_datas\" */\n  token_datas: Array<TokenDatas>;\n  /** fetch data from the table: \"token_datas\" using primary key columns */\n  token_datas_by_pk?: Maybe<TokenDatas>;\n  /** fetch data from the table: \"token_ownerships\" */\n  token_ownerships: Array<TokenOwnerships>;\n  /** fetch data from the table: \"token_ownerships\" using primary key columns */\n  token_ownerships_by_pk?: Maybe<TokenOwnerships>;\n  /** fetch data from the table: \"tokens\" */\n  tokens: Array<Tokens>;\n  /** fetch data from the table: \"tokens\" using primary key columns */\n  tokens_by_pk?: Maybe<Tokens>;\n  /** fetch data from the table: \"user_transactions\" */\n  user_transactions: Array<UserTransactions>;\n  /** fetch data from the table: \"user_transactions\" using primary key columns */\n  user_transactions_by_pk?: Maybe<UserTransactions>;\n};\n\nexport type QueryRootAccountTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type QueryRootAccountTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type QueryRootAccountTransactionsByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootAddressEventsSummaryArgs = {\n  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromEventsArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromEventsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type QueryRootBlockMetadataTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type QueryRootBlockMetadataTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type QueryRootCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type QueryRootCoinActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type QueryRootCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCoinInfosArgs = {\n  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type QueryRootCoinInfosByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCoinSupplyArgs = {\n  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type QueryRootCoinSupplyByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type QueryRootCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCurrentAnsLookupArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type QueryRootCurrentAnsLookupByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentAnsLookupV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type QueryRootCurrentAnsLookupV2ByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentAptosNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\nexport type QueryRootCurrentAptosNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\nexport type QueryRootCurrentCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentCollectionOwnershipV2ViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionOwnershipV2ViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type QueryRootCurrentCollectionsV2ByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentDelegatedVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatedVoterByPkArgs = {\n  delegation_pool_address: Scalars[\"String\"][\"input\"];\n  delegator_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentDelegatorBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatorBalancesByPkArgs = {\n  delegator_address: Scalars[\"String\"][\"input\"];\n  pool_address: Scalars[\"String\"][\"input\"];\n  pool_type: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentObjectsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type QueryRootCurrentObjectsByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentStakingPoolVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type QueryRootCurrentStakingPoolVoterByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type QueryRootCurrentTableItemsByPkArgs = {\n  key_hash: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenDatasV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasV2ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenOwnershipsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsV2ByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version_v1: Scalars[\"numeric\"][\"input\"];\n  storage_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenPendingClaimsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenPendingClaimsByPkArgs = {\n  from_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  to_address: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootDelegatedStakingPoolsArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolsByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootDelegatorDistinctPoolArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type QueryRootDelegatorDistinctPoolAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type QueryRootEventsArgs = {\n  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsOrderBy>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type QueryRootEventsByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootFungibleAssetActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type QueryRootFungibleAssetActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootFungibleAssetMetadataArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type QueryRootFungibleAssetMetadataByPkArgs = {\n  asset_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootIndexerStatusArgs = {\n  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type QueryRootIndexerStatusByPkArgs = {\n  db: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootLedgerInfosArgs = {\n  distinct_on?: InputMaybe<Array<LedgerInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<LedgerInfosOrderBy>>;\n  where?: InputMaybe<LedgerInfosBoolExp>;\n};\n\nexport type QueryRootLedgerInfosByPkArgs = {\n  chain_id: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type QueryRootMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceAuctionsArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceAuctionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceAuctionsOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceAuctionsByPkArgs = {\n  listing_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceCollectionOffersArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceCollectionOffersByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n  collection_offer_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceListingsArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceListingsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceListingsByPkArgs = {\n  listing_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceTokenOffersArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffersSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffersOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2CurrentNftMarketplaceTokenOffersByPkArgs = {\n  offer_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootNftMarketplaceV2NftMarketplaceActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2NftMarketplaceActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2NftMarketplaceActivitiesOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2NftMarketplaceActivitiesBoolExp>;\n};\n\nexport type QueryRootNftMarketplaceV2NftMarketplaceActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootNftMetadataCrawlerParsedAssetUrisArgs = {\n  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type QueryRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {\n  asset_uri: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootNumActiveDelegatorPerPoolArgs = {\n  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type QueryRootProcessorStatusArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type QueryRootProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootProposalVotesArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type QueryRootProposalVotesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type QueryRootProposalVotesByPkArgs = {\n  proposal_id: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  voter_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootSignaturesArgs = {\n  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SignaturesOrderBy>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type QueryRootSignaturesByPkArgs = {\n  is_sender_primary: Scalars[\"Boolean\"][\"input\"];\n  multi_agent_index: Scalars[\"bigint\"][\"input\"];\n  multi_sig_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsOrderBy>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type QueryRootTableItemsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTableMetadatasArgs = {\n  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type QueryRootTableMetadatasByPkArgs = {\n  handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type QueryRootTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type QueryRootTokenActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type QueryRootTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type QueryRootTokenActivitiesV2ByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type QueryRootTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootTokenOwnershipsByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokensArgs = {\n  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokensOrderBy>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type QueryRootTokensByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootUserTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\nexport type QueryRootUserTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** columns and relationships of \"signatures\" */\nexport type Signatures = {\n  is_sender_primary: Scalars[\"Boolean\"][\"output\"];\n  multi_agent_index: Scalars[\"bigint\"][\"output\"];\n  multi_sig_index: Scalars[\"bigint\"][\"output\"];\n  public_key: Scalars[\"String\"][\"output\"];\n  public_key_indices: Scalars[\"jsonb\"][\"output\"];\n  signature: Scalars[\"String\"][\"output\"];\n  signer: Scalars[\"String\"][\"output\"];\n  threshold: Scalars[\"bigint\"][\"output\"];\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"signatures\" */\nexport type SignaturesPublicKeyIndicesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"signatures\". All fields are combined with a logical 'AND'. */\nexport type SignaturesBoolExp = {\n  _and?: InputMaybe<Array<SignaturesBoolExp>>;\n  _not?: InputMaybe<SignaturesBoolExp>;\n  _or?: InputMaybe<Array<SignaturesBoolExp>>;\n  is_sender_primary?: InputMaybe<BooleanComparisonExp>;\n  multi_agent_index?: InputMaybe<BigintComparisonExp>;\n  multi_sig_index?: InputMaybe<BigintComparisonExp>;\n  public_key?: InputMaybe<StringComparisonExp>;\n  public_key_indices?: InputMaybe<JsonbComparisonExp>;\n  signature?: InputMaybe<StringComparisonExp>;\n  signer?: InputMaybe<StringComparisonExp>;\n  threshold?: InputMaybe<BigintComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"signatures\". */\nexport type SignaturesOrderBy = {\n  is_sender_primary?: InputMaybe<OrderBy>;\n  multi_agent_index?: InputMaybe<OrderBy>;\n  multi_sig_index?: InputMaybe<OrderBy>;\n  public_key?: InputMaybe<OrderBy>;\n  public_key_indices?: InputMaybe<OrderBy>;\n  signature?: InputMaybe<OrderBy>;\n  signer?: InputMaybe<OrderBy>;\n  threshold?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"signatures\" */\nexport enum SignaturesSelectColumn {\n  /** column name */\n  IsSenderPrimary = \"is_sender_primary\",\n  /** column name */\n  MultiAgentIndex = \"multi_agent_index\",\n  /** column name */\n  MultiSigIndex = \"multi_sig_index\",\n  /** column name */\n  PublicKey = \"public_key\",\n  /** column name */\n  PublicKeyIndices = \"public_key_indices\",\n  /** column name */\n  Signature = \"signature\",\n  /** column name */\n  Signer = \"signer\",\n  /** column name */\n  Threshold = \"threshold\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** Streaming cursor of the table \"signatures\" */\nexport type SignaturesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: SignaturesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type SignaturesStreamCursorValueInput = {\n  is_sender_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  multi_agent_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  multi_sig_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  signature?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  threshold?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\nexport type SubscriptionRoot = {\n  /** fetch data from the table: \"account_transactions\" */\n  account_transactions: Array<AccountTransactions>;\n  /** fetch aggregated fields from the table: \"account_transactions\" */\n  account_transactions_aggregate: AccountTransactionsAggregate;\n  /** fetch data from the table: \"account_transactions\" using primary key columns */\n  account_transactions_by_pk?: Maybe<AccountTransactions>;\n  /** fetch data from the table in a streaming manner: \"account_transactions\" */\n  account_transactions_stream: Array<AccountTransactions>;\n  /** fetch data from the table: \"address_events_summary\" */\n  address_events_summary: Array<AddressEventsSummary>;\n  /** fetch data from the table in a streaming manner: \"address_events_summary\" */\n  address_events_summary_stream: Array<AddressEventsSummary>;\n  /** fetch data from the table: \"address_version_from_events\" */\n  address_version_from_events: Array<AddressVersionFromEvents>;\n  /** fetch aggregated fields from the table: \"address_version_from_events\" */\n  address_version_from_events_aggregate: AddressVersionFromEventsAggregate;\n  /** fetch data from the table in a streaming manner: \"address_version_from_events\" */\n  address_version_from_events_stream: Array<AddressVersionFromEvents>;\n  /** fetch data from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources: Array<AddressVersionFromMoveResources>;\n  /** fetch aggregated fields from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;\n  /** fetch data from the table in a streaming manner: \"address_version_from_move_resources\" */\n  address_version_from_move_resources_stream: Array<AddressVersionFromMoveResources>;\n  /** fetch data from the table: \"block_metadata_transactions\" */\n  block_metadata_transactions: Array<BlockMetadataTransactions>;\n  /** fetch data from the table: \"block_metadata_transactions\" using primary key columns */\n  block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;\n  /** fetch data from the table in a streaming manner: \"block_metadata_transactions\" */\n  block_metadata_transactions_stream: Array<BlockMetadataTransactions>;\n  /** An array relationship */\n  coin_activities: Array<CoinActivities>;\n  /** An aggregate relationship */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** fetch data from the table: \"coin_activities\" using primary key columns */\n  coin_activities_by_pk?: Maybe<CoinActivities>;\n  /** fetch data from the table in a streaming manner: \"coin_activities\" */\n  coin_activities_stream: Array<CoinActivities>;\n  /** fetch data from the table: \"coin_balances\" */\n  coin_balances: Array<CoinBalances>;\n  /** fetch data from the table: \"coin_balances\" using primary key columns */\n  coin_balances_by_pk?: Maybe<CoinBalances>;\n  /** fetch data from the table in a streaming manner: \"coin_balances\" */\n  coin_balances_stream: Array<CoinBalances>;\n  /** fetch data from the table: \"coin_infos\" */\n  coin_infos: Array<CoinInfos>;\n  /** fetch data from the table: \"coin_infos\" using primary key columns */\n  coin_infos_by_pk?: Maybe<CoinInfos>;\n  /** fetch data from the table in a streaming manner: \"coin_infos\" */\n  coin_infos_stream: Array<CoinInfos>;\n  /** fetch data from the table: \"coin_supply\" */\n  coin_supply: Array<CoinSupply>;\n  /** fetch data from the table: \"coin_supply\" using primary key columns */\n  coin_supply_by_pk?: Maybe<CoinSupply>;\n  /** fetch data from the table in a streaming manner: \"coin_supply\" */\n  coin_supply_stream: Array<CoinSupply>;\n  /** fetch data from the table: \"collection_datas\" */\n  collection_datas: Array<CollectionDatas>;\n  /** fetch data from the table: \"collection_datas\" using primary key columns */\n  collection_datas_by_pk?: Maybe<CollectionDatas>;\n  /** fetch data from the table in a streaming manner: \"collection_datas\" */\n  collection_datas_stream: Array<CollectionDatas>;\n  /** fetch data from the table: \"current_ans_lookup\" */\n  current_ans_lookup: Array<CurrentAnsLookup>;\n  /** fetch data from the table: \"current_ans_lookup\" using primary key columns */\n  current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;\n  /** fetch data from the table in a streaming manner: \"current_ans_lookup\" */\n  current_ans_lookup_stream: Array<CurrentAnsLookup>;\n  /** fetch data from the table: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2: Array<CurrentAnsLookupV2>;\n  /** fetch data from the table: \"current_ans_lookup_v2\" using primary key columns */\n  current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;\n  /** fetch data from the table in a streaming manner: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2_stream: Array<CurrentAnsLookupV2>;\n  /** fetch data from the table: \"current_aptos_names\" */\n  current_aptos_names: Array<CurrentAptosNames>;\n  /** fetch aggregated fields from the table: \"current_aptos_names\" */\n  current_aptos_names_aggregate: CurrentAptosNamesAggregate;\n  /** fetch data from the table in a streaming manner: \"current_aptos_names\" */\n  current_aptos_names_stream: Array<CurrentAptosNames>;\n  /** fetch data from the table: \"current_coin_balances\" */\n  current_coin_balances: Array<CurrentCoinBalances>;\n  /** fetch data from the table: \"current_coin_balances\" using primary key columns */\n  current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;\n  /** fetch data from the table in a streaming manner: \"current_coin_balances\" */\n  current_coin_balances_stream: Array<CurrentCoinBalances>;\n  /** fetch data from the table: \"current_collection_datas\" */\n  current_collection_datas: Array<CurrentCollectionDatas>;\n  /** fetch data from the table: \"current_collection_datas\" using primary key columns */\n  current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;\n  /** fetch data from the table in a streaming manner: \"current_collection_datas\" */\n  current_collection_datas_stream: Array<CurrentCollectionDatas>;\n  /** fetch data from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;\n  /** fetch aggregated fields from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;\n  /** fetch data from the table in a streaming manner: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view_stream: Array<CurrentCollectionOwnershipV2View>;\n  /** fetch data from the table: \"current_collections_v2\" */\n  current_collections_v2: Array<CurrentCollectionsV2>;\n  /** fetch data from the table: \"current_collections_v2\" using primary key columns */\n  current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;\n  /** fetch data from the table in a streaming manner: \"current_collections_v2\" */\n  current_collections_v2_stream: Array<CurrentCollectionsV2>;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" using primary key columns */\n  current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table in a streaming manner: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances_stream: Array<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"current_delegated_voter\" */\n  current_delegated_voter: Array<CurrentDelegatedVoter>;\n  /** fetch data from the table: \"current_delegated_voter\" using primary key columns */\n  current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;\n  /** fetch data from the table in a streaming manner: \"current_delegated_voter\" */\n  current_delegated_voter_stream: Array<CurrentDelegatedVoter>;\n  /** fetch data from the table: \"current_delegator_balances\" */\n  current_delegator_balances: Array<CurrentDelegatorBalances>;\n  /** fetch data from the table: \"current_delegator_balances\" using primary key columns */\n  current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;\n  /** fetch data from the table in a streaming manner: \"current_delegator_balances\" */\n  current_delegator_balances_stream: Array<CurrentDelegatorBalances>;\n  /** fetch data from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;\n  /** fetch aggregated fields from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;\n  /** fetch data from the table: \"current_fungible_asset_balances\" using primary key columns */\n  current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;\n  /** fetch data from the table in a streaming manner: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_stream: Array<CurrentFungibleAssetBalances>;\n  /** fetch data from the table: \"current_objects\" */\n  current_objects: Array<CurrentObjects>;\n  /** fetch data from the table: \"current_objects\" using primary key columns */\n  current_objects_by_pk?: Maybe<CurrentObjects>;\n  /** fetch data from the table in a streaming manner: \"current_objects\" */\n  current_objects_stream: Array<CurrentObjects>;\n  /** fetch data from the table: \"current_staking_pool_voter\" */\n  current_staking_pool_voter: Array<CurrentStakingPoolVoter>;\n  /** fetch data from the table: \"current_staking_pool_voter\" using primary key columns */\n  current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;\n  /** fetch data from the table in a streaming manner: \"current_staking_pool_voter\" */\n  current_staking_pool_voter_stream: Array<CurrentStakingPoolVoter>;\n  /** fetch data from the table: \"current_table_items\" */\n  current_table_items: Array<CurrentTableItems>;\n  /** fetch data from the table: \"current_table_items\" using primary key columns */\n  current_table_items_by_pk?: Maybe<CurrentTableItems>;\n  /** fetch data from the table in a streaming manner: \"current_table_items\" */\n  current_table_items_stream: Array<CurrentTableItems>;\n  /** fetch data from the table: \"current_token_datas\" */\n  current_token_datas: Array<CurrentTokenDatas>;\n  /** fetch data from the table: \"current_token_datas\" using primary key columns */\n  current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;\n  /** fetch data from the table in a streaming manner: \"current_token_datas\" */\n  current_token_datas_stream: Array<CurrentTokenDatas>;\n  /** fetch data from the table: \"current_token_datas_v2\" */\n  current_token_datas_v2: Array<CurrentTokenDatasV2>;\n  /** fetch data from the table: \"current_token_datas_v2\" using primary key columns */\n  current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;\n  /** fetch data from the table in a streaming manner: \"current_token_datas_v2\" */\n  current_token_datas_v2_stream: Array<CurrentTokenDatasV2>;\n  /** fetch data from the table: \"current_token_ownerships\" */\n  current_token_ownerships: Array<CurrentTokenOwnerships>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships\" */\n  current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;\n  /** fetch data from the table: \"current_token_ownerships\" using primary key columns */\n  current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;\n  /** fetch data from the table in a streaming manner: \"current_token_ownerships\" */\n  current_token_ownerships_stream: Array<CurrentTokenOwnerships>;\n  /** fetch data from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  /** fetch data from the table: \"current_token_ownerships_v2\" using primary key columns */\n  current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;\n  /** fetch data from the table in a streaming manner: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2_stream: Array<CurrentTokenOwnershipsV2>;\n  /** fetch data from the table: \"current_token_pending_claims\" */\n  current_token_pending_claims: Array<CurrentTokenPendingClaims>;\n  /** fetch data from the table: \"current_token_pending_claims\" using primary key columns */\n  current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;\n  /** fetch data from the table in a streaming manner: \"current_token_pending_claims\" */\n  current_token_pending_claims_stream: Array<CurrentTokenPendingClaims>;\n  /** An array relationship */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** fetch data from the table: \"delegated_staking_activities\" using primary key columns */\n  delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;\n  /** fetch data from the table in a streaming manner: \"delegated_staking_activities\" */\n  delegated_staking_activities_stream: Array<DelegatedStakingActivities>;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;\n  /** fetch aggregated fields from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" using primary key columns */\n  delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;\n  /** fetch data from the table in a streaming manner: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances_stream: Array<DelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"delegated_staking_pools\" */\n  delegated_staking_pools: Array<DelegatedStakingPools>;\n  /** fetch data from the table: \"delegated_staking_pools\" using primary key columns */\n  delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;\n  /** fetch data from the table in a streaming manner: \"delegated_staking_pools\" */\n  delegated_staking_pools_stream: Array<DelegatedStakingPools>;\n  /** fetch data from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool: Array<DelegatorDistinctPool>;\n  /** fetch aggregated fields from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;\n  /** fetch data from the table in a streaming manner: \"delegator_distinct_pool\" */\n  delegator_distinct_pool_stream: Array<DelegatorDistinctPool>;\n  /** fetch data from the table: \"events\" */\n  events: Array<Events>;\n  /** fetch data from the table: \"events\" using primary key columns */\n  events_by_pk?: Maybe<Events>;\n  /** fetch data from the table in a streaming manner: \"events\" */\n  events_stream: Array<Events>;\n  /** An array relationship */\n  fungible_asset_activities: Array<FungibleAssetActivities>;\n  /** fetch data from the table: \"fungible_asset_activities\" using primary key columns */\n  fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;\n  /** fetch data from the table in a streaming manner: \"fungible_asset_activities\" */\n  fungible_asset_activities_stream: Array<FungibleAssetActivities>;\n  /** fetch data from the table: \"fungible_asset_metadata\" */\n  fungible_asset_metadata: Array<FungibleAssetMetadata>;\n  /** fetch data from the table: \"fungible_asset_metadata\" using primary key columns */\n  fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;\n  /** fetch data from the table in a streaming manner: \"fungible_asset_metadata\" */\n  fungible_asset_metadata_stream: Array<FungibleAssetMetadata>;\n  /** fetch data from the table: \"indexer_status\" */\n  indexer_status: Array<IndexerStatus>;\n  /** fetch data from the table: \"indexer_status\" using primary key columns */\n  indexer_status_by_pk?: Maybe<IndexerStatus>;\n  /** fetch data from the table in a streaming manner: \"indexer_status\" */\n  indexer_status_stream: Array<IndexerStatus>;\n  /** fetch data from the table: \"ledger_infos\" */\n  ledger_infos: Array<LedgerInfos>;\n  /** fetch data from the table: \"ledger_infos\" using primary key columns */\n  ledger_infos_by_pk?: Maybe<LedgerInfos>;\n  /** fetch data from the table in a streaming manner: \"ledger_infos\" */\n  ledger_infos_stream: Array<LedgerInfos>;\n  /** fetch data from the table: \"move_resources\" */\n  move_resources: Array<MoveResources>;\n  /** fetch aggregated fields from the table: \"move_resources\" */\n  move_resources_aggregate: MoveResourcesAggregate;\n  /** fetch data from the table in a streaming manner: \"move_resources\" */\n  move_resources_stream: Array<MoveResources>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\" */\n  nft_marketplace_v2_current_nft_marketplace_auctions: Array<NftMarketplaceV2CurrentNftMarketplaceAuctions>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_auctions_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceAuctions>;\n  /** fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_auctions\" */\n  nft_marketplace_v2_current_nft_marketplace_auctions_stream: Array<NftMarketplaceV2CurrentNftMarketplaceAuctions>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" */\n  nft_marketplace_v2_current_nft_marketplace_collection_offers: Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_collection_offers_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffers>;\n  /** fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" */\n  nft_marketplace_v2_current_nft_marketplace_collection_offers_stream: Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" */\n  nft_marketplace_v2_current_nft_marketplace_listings: Array<NftMarketplaceV2CurrentNftMarketplaceListings>;\n  /** fetch aggregated fields from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" */\n  nft_marketplace_v2_current_nft_marketplace_listings_aggregate: NftMarketplaceV2CurrentNftMarketplaceListingsAggregate;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_listings_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceListings>;\n  /** fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_listings\" */\n  nft_marketplace_v2_current_nft_marketplace_listings_stream: Array<NftMarketplaceV2CurrentNftMarketplaceListings>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" */\n  nft_marketplace_v2_current_nft_marketplace_token_offers: Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" using primary key columns */\n  nft_marketplace_v2_current_nft_marketplace_token_offers_by_pk?: Maybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffers>;\n  /** fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" */\n  nft_marketplace_v2_current_nft_marketplace_token_offers_stream: Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffers>;\n  /** fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\" */\n  nft_marketplace_v2_nft_marketplace_activities: Array<NftMarketplaceV2NftMarketplaceActivities>;\n  /** fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\" using primary key columns */\n  nft_marketplace_v2_nft_marketplace_activities_by_pk?: Maybe<NftMarketplaceV2NftMarketplaceActivities>;\n  /** fetch data from the table in a streaming manner: \"nft_marketplace_v2.nft_marketplace_activities\" */\n  nft_marketplace_v2_nft_marketplace_activities_stream: Array<NftMarketplaceV2NftMarketplaceActivities>;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" using primary key columns */\n  nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table in a streaming manner: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris_stream: Array<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;\n  /** fetch data from the table in a streaming manner: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool_stream: Array<NumActiveDelegatorPerPool>;\n  /** fetch data from the table: \"processor_status\" */\n  processor_status: Array<ProcessorStatus>;\n  /** fetch data from the table: \"processor_status\" using primary key columns */\n  processor_status_by_pk?: Maybe<ProcessorStatus>;\n  /** fetch data from the table in a streaming manner: \"processor_status\" */\n  processor_status_stream: Array<ProcessorStatus>;\n  /** fetch data from the table: \"proposal_votes\" */\n  proposal_votes: Array<ProposalVotes>;\n  /** fetch aggregated fields from the table: \"proposal_votes\" */\n  proposal_votes_aggregate: ProposalVotesAggregate;\n  /** fetch data from the table: \"proposal_votes\" using primary key columns */\n  proposal_votes_by_pk?: Maybe<ProposalVotes>;\n  /** fetch data from the table in a streaming manner: \"proposal_votes\" */\n  proposal_votes_stream: Array<ProposalVotes>;\n  /** fetch data from the table: \"signatures\" */\n  signatures: Array<Signatures>;\n  /** fetch data from the table: \"signatures\" using primary key columns */\n  signatures_by_pk?: Maybe<Signatures>;\n  /** fetch data from the table in a streaming manner: \"signatures\" */\n  signatures_stream: Array<Signatures>;\n  /** fetch data from the table: \"table_items\" */\n  table_items: Array<TableItems>;\n  /** fetch data from the table: \"table_items\" using primary key columns */\n  table_items_by_pk?: Maybe<TableItems>;\n  /** fetch data from the table in a streaming manner: \"table_items\" */\n  table_items_stream: Array<TableItems>;\n  /** fetch data from the table: \"table_metadatas\" */\n  table_metadatas: Array<TableMetadatas>;\n  /** fetch data from the table: \"table_metadatas\" using primary key columns */\n  table_metadatas_by_pk?: Maybe<TableMetadatas>;\n  /** fetch data from the table in a streaming manner: \"table_metadatas\" */\n  table_metadatas_stream: Array<TableMetadatas>;\n  /** An array relationship */\n  token_activities: Array<TokenActivities>;\n  /** An aggregate relationship */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** fetch data from the table: \"token_activities\" using primary key columns */\n  token_activities_by_pk?: Maybe<TokenActivities>;\n  /** fetch data from the table in a streaming manner: \"token_activities\" */\n  token_activities_stream: Array<TokenActivities>;\n  /** An array relationship */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** An aggregate relationship */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  /** fetch data from the table: \"token_activities_v2\" using primary key columns */\n  token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;\n  /** fetch data from the table in a streaming manner: \"token_activities_v2\" */\n  token_activities_v2_stream: Array<TokenActivitiesV2>;\n  /** fetch data from the table: \"token_datas\" */\n  token_datas: Array<TokenDatas>;\n  /** fetch data from the table: \"token_datas\" using primary key columns */\n  token_datas_by_pk?: Maybe<TokenDatas>;\n  /** fetch data from the table in a streaming manner: \"token_datas\" */\n  token_datas_stream: Array<TokenDatas>;\n  /** fetch data from the table: \"token_ownerships\" */\n  token_ownerships: Array<TokenOwnerships>;\n  /** fetch data from the table: \"token_ownerships\" using primary key columns */\n  token_ownerships_by_pk?: Maybe<TokenOwnerships>;\n  /** fetch data from the table in a streaming manner: \"token_ownerships\" */\n  token_ownerships_stream: Array<TokenOwnerships>;\n  /** fetch data from the table: \"tokens\" */\n  tokens: Array<Tokens>;\n  /** fetch data from the table: \"tokens\" using primary key columns */\n  tokens_by_pk?: Maybe<Tokens>;\n  /** fetch data from the table in a streaming manner: \"tokens\" */\n  tokens_stream: Array<Tokens>;\n  /** fetch data from the table: \"user_transactions\" */\n  user_transactions: Array<UserTransactions>;\n  /** fetch data from the table: \"user_transactions\" using primary key columns */\n  user_transactions_by_pk?: Maybe<UserTransactions>;\n  /** fetch data from the table in a streaming manner: \"user_transactions\" */\n  user_transactions_stream: Array<UserTransactions>;\n};\n\nexport type SubscriptionRootAccountTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootAccountTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootAccountTransactionsByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootAccountTransactionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AccountTransactionsStreamCursorInput>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootAddressEventsSummaryArgs = {\n  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type SubscriptionRootAddressEventsSummaryStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AddressEventsSummaryStreamCursorInput>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromEventsArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromEventsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromEventsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AddressVersionFromEventsStreamCursorInput>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromMoveResourcesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AddressVersionFromMoveResourcesStreamCursorInput>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<BlockMetadataTransactionsStreamCursorInput>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootCoinActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinActivitiesStreamCursorInput>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinBalancesStreamCursorInput>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCoinInfosArgs = {\n  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type SubscriptionRootCoinInfosByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinInfosStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinInfosStreamCursorInput>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type SubscriptionRootCoinSupplyArgs = {\n  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type SubscriptionRootCoinSupplyByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinSupplyStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinSupplyStreamCursorInput>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type SubscriptionRootCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCollectionDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CollectionDatasStreamCursorInput>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentAnsLookupStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAnsLookupStreamCursorInput>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2ByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAnsLookupV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAptosNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAptosNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAptosNamesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAptosNamesStreamCursorInput>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentCoinBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCoinBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentCollectionDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionDatasStreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipV2ViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipV2ViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipV2ViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionOwnershipV2ViewStreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionsV2ByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentCollectionsV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionsV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentDelegatedStakingPoolBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterByPkArgs = {\n  delegation_pool_address: Scalars[\"String\"][\"input\"];\n  delegator_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentDelegatedVoterStreamCursorInput>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesByPkArgs = {\n  delegator_address: Scalars[\"String\"][\"input\"];\n  pool_address: Scalars[\"String\"][\"input\"];\n  pool_type: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentDelegatorBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentFungibleAssetBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentObjectsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentObjectsByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentObjectsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentObjectsStreamCursorInput>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentStakingPoolVoterStreamCursorInput>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsByPkArgs = {\n  key_hash: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTableItemsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTableItemsStreamCursorInput>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenDatasStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenDatasV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenOwnershipsStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2ByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version_v1: Scalars[\"numeric\"][\"input\"];\n  storage_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenOwnershipsV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsByPkArgs = {\n  from_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  to_address: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenPendingClaimsStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatedStakingActivitiesStreamCursorInput>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatedStakingPoolBalancesStreamCursorInput>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatedStakingPoolsStreamCursorInput>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorDistinctPoolArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorDistinctPoolAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorDistinctPoolStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatorDistinctPoolStreamCursorInput>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type SubscriptionRootEventsArgs = {\n  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsOrderBy>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type SubscriptionRootEventsByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootEventsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<EventsStreamCursorInput>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<FungibleAssetActivitiesStreamCursorInput>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetMetadataArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetMetadataByPkArgs = {\n  asset_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootFungibleAssetMetadataStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<FungibleAssetMetadataStreamCursorInput>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type SubscriptionRootIndexerStatusArgs = {\n  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type SubscriptionRootIndexerStatusByPkArgs = {\n  db: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootIndexerStatusStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<IndexerStatusStreamCursorInput>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type SubscriptionRootLedgerInfosArgs = {\n  distinct_on?: InputMaybe<Array<LedgerInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<LedgerInfosOrderBy>>;\n  where?: InputMaybe<LedgerInfosBoolExp>;\n};\n\nexport type SubscriptionRootLedgerInfosByPkArgs = {\n  chain_id: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootLedgerInfosStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<LedgerInfosStreamCursorInput>>;\n  where?: InputMaybe<LedgerInfosBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<MoveResourcesStreamCursorInput>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceAuctionsArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceAuctionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceAuctionsOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceAuctionsByPkArgs = {\n  listing_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceAuctionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMarketplaceV2CurrentNftMarketplaceAuctionsStreamCursorInput>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceAuctionsBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceCollectionOffersArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceCollectionOffersByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n  collection_offer_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceCollectionOffersStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersStreamCursorInput>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceCollectionOffersBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceListingsArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceListingsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceListingsOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceListingsByPkArgs = {\n  listing_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceListingsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsStreamCursorInput>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceListingsBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceTokenOffersArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffersSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2CurrentNftMarketplaceTokenOffersOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceTokenOffersByPkArgs = {\n  offer_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMarketplaceV2CurrentNftMarketplaceTokenOffersStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffersStreamCursorInput>>;\n  where?: InputMaybe<NftMarketplaceV2CurrentNftMarketplaceTokenOffersBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2NftMarketplaceActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<NftMarketplaceV2NftMarketplaceActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMarketplaceV2NftMarketplaceActivitiesOrderBy>>;\n  where?: InputMaybe<NftMarketplaceV2NftMarketplaceActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootNftMarketplaceV2NftMarketplaceActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMarketplaceV2NftMarketplaceActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMarketplaceV2NftMarketplaceActivitiesStreamCursorInput>>;\n  where?: InputMaybe<NftMarketplaceV2NftMarketplaceActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisArgs = {\n  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {\n  asset_uri: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMetadataCrawlerParsedAssetUrisStreamCursorInput>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type SubscriptionRootNumActiveDelegatorPerPoolArgs = {\n  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type SubscriptionRootNumActiveDelegatorPerPoolStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NumActiveDelegatorPerPoolStreamCursorInput>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type SubscriptionRootProcessorStatusArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootProcessorStatusStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<ProcessorStatusStreamCursorInput>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProposalVotesArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type SubscriptionRootProposalVotesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type SubscriptionRootProposalVotesByPkArgs = {\n  proposal_id: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  voter_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootProposalVotesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<ProposalVotesStreamCursorInput>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type SubscriptionRootSignaturesArgs = {\n  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SignaturesOrderBy>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type SubscriptionRootSignaturesByPkArgs = {\n  is_sender_primary: Scalars[\"Boolean\"][\"input\"];\n  multi_agent_index: Scalars[\"bigint\"][\"input\"];\n  multi_sig_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootSignaturesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<SignaturesStreamCursorInput>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsOrderBy>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTableItemsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TableItemsStreamCursorInput>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type SubscriptionRootTableMetadatasArgs = {\n  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type SubscriptionRootTableMetadatasByPkArgs = {\n  handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootTableMetadatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TableMetadatasStreamCursorInput>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenActivitiesStreamCursorInput>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesV2ByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenActivitiesV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenActivitiesV2StreamCursorInput>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenDatasStreamCursorInput>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenOwnershipsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenOwnershipsStreamCursorInput>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootTokensArgs = {\n  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokensOrderBy>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type SubscriptionRootTokensByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokensStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokensStreamCursorInput>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type SubscriptionRootUserTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootUserTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootUserTransactionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<UserTransactionsStreamCursorInput>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\n/** columns and relationships of \"table_items\" */\nexport type TableItems = {\n  decoded_key: Scalars[\"jsonb\"][\"output\"];\n  decoded_value?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  key: Scalars[\"String\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"table_items\" */\nexport type TableItemsDecodedKeyArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"table_items\" */\nexport type TableItemsDecodedValueArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"table_items\". All fields are combined with a logical 'AND'. */\nexport type TableItemsBoolExp = {\n  _and?: InputMaybe<Array<TableItemsBoolExp>>;\n  _not?: InputMaybe<TableItemsBoolExp>;\n  _or?: InputMaybe<Array<TableItemsBoolExp>>;\n  decoded_key?: InputMaybe<JsonbComparisonExp>;\n  decoded_value?: InputMaybe<JsonbComparisonExp>;\n  key?: InputMaybe<StringComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"table_items\". */\nexport type TableItemsOrderBy = {\n  decoded_key?: InputMaybe<OrderBy>;\n  decoded_value?: InputMaybe<OrderBy>;\n  key?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"table_items\" */\nexport enum TableItemsSelectColumn {\n  /** column name */\n  DecodedKey = \"decoded_key\",\n  /** column name */\n  DecodedValue = \"decoded_value\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** Streaming cursor of the table \"table_items\" */\nexport type TableItemsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TableItemsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TableItemsStreamCursorValueInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"table_metadatas\" */\nexport type TableMetadatas = {\n  handle: Scalars[\"String\"][\"output\"];\n  key_type: Scalars[\"String\"][\"output\"];\n  value_type: Scalars[\"String\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"table_metadatas\". All fields are combined with a logical 'AND'. */\nexport type TableMetadatasBoolExp = {\n  _and?: InputMaybe<Array<TableMetadatasBoolExp>>;\n  _not?: InputMaybe<TableMetadatasBoolExp>;\n  _or?: InputMaybe<Array<TableMetadatasBoolExp>>;\n  handle?: InputMaybe<StringComparisonExp>;\n  key_type?: InputMaybe<StringComparisonExp>;\n  value_type?: InputMaybe<StringComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"table_metadatas\". */\nexport type TableMetadatasOrderBy = {\n  handle?: InputMaybe<OrderBy>;\n  key_type?: InputMaybe<OrderBy>;\n  value_type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"table_metadatas\" */\nexport enum TableMetadatasSelectColumn {\n  /** column name */\n  Handle = \"handle\",\n  /** column name */\n  KeyType = \"key_type\",\n  /** column name */\n  ValueType = \"value_type\",\n}\n\n/** Streaming cursor of the table \"table_metadatas\" */\nexport type TableMetadatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TableMetadatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TableMetadatasStreamCursorValueInput = {\n  handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  value_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'. */\nexport type TimestampComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"timestamp\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"timestamp\"][\"input\"]>>;\n};\n\n/** Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'. */\nexport type TimestamptzComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"timestamptz\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"timestamptz\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"timestamptz\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"token_activities\" */\nexport type TokenActivities = {\n  /** An array relationship */\n  aptos_names_owner: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  aptos_names_owner_aggregate: CurrentAptosNamesAggregate;\n  /** An array relationship */\n  aptos_names_to: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  aptos_names_to_aggregate: CurrentAptosNamesAggregate;\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatas>;\n  event_account_address: Scalars[\"String\"][\"output\"];\n  event_creation_number: Scalars[\"bigint\"][\"output\"];\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number: Scalars[\"bigint\"][\"output\"];\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  transfer_type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"token_activities\" */\nexport type TokenActivitiesAptosNamesOwnerArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities\" */\nexport type TokenActivitiesAptosNamesOwnerAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities\" */\nexport type TokenActivitiesAptosNamesToArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities\" */\nexport type TokenActivitiesAptosNamesToAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** aggregated selection of \"token_activities\" */\nexport type TokenActivitiesAggregate = {\n  aggregate?: Maybe<TokenActivitiesAggregateFields>;\n  nodes: Array<TokenActivities>;\n};\n\nexport type TokenActivitiesAggregateBoolExp = {\n  count?: InputMaybe<TokenActivitiesAggregateBoolExpCount>;\n};\n\nexport type TokenActivitiesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"token_activities\" */\nexport type TokenActivitiesAggregateFields = {\n  avg?: Maybe<TokenActivitiesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenActivitiesMaxFields>;\n  min?: Maybe<TokenActivitiesMinFields>;\n  stddev?: Maybe<TokenActivitiesStddevFields>;\n  stddev_pop?: Maybe<TokenActivitiesStddevPopFields>;\n  stddev_samp?: Maybe<TokenActivitiesStddevSampFields>;\n  sum?: Maybe<TokenActivitiesSumFields>;\n  var_pop?: Maybe<TokenActivitiesVarPopFields>;\n  var_samp?: Maybe<TokenActivitiesVarSampFields>;\n  variance?: Maybe<TokenActivitiesVarianceFields>;\n};\n\n/** aggregate fields of \"token_activities\" */\nexport type TokenActivitiesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"token_activities\" */\nexport type TokenActivitiesAggregateOrderBy = {\n  avg?: InputMaybe<TokenActivitiesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<TokenActivitiesMaxOrderBy>;\n  min?: InputMaybe<TokenActivitiesMinOrderBy>;\n  stddev?: InputMaybe<TokenActivitiesStddevOrderBy>;\n  stddev_pop?: InputMaybe<TokenActivitiesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<TokenActivitiesStddevSampOrderBy>;\n  sum?: InputMaybe<TokenActivitiesSumOrderBy>;\n  var_pop?: InputMaybe<TokenActivitiesVarPopOrderBy>;\n  var_samp?: InputMaybe<TokenActivitiesVarSampOrderBy>;\n  variance?: InputMaybe<TokenActivitiesVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type TokenActivitiesAvgFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"token_activities\" */\nexport type TokenActivitiesAvgOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"token_activities\". All fields are combined with a logical 'AND'. */\nexport type TokenActivitiesBoolExp = {\n  _and?: InputMaybe<Array<TokenActivitiesBoolExp>>;\n  _not?: InputMaybe<TokenActivitiesBoolExp>;\n  _or?: InputMaybe<Array<TokenActivitiesBoolExp>>;\n  aptos_names_owner?: InputMaybe<CurrentAptosNamesBoolExp>;\n  aptos_names_owner_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  aptos_names_to?: InputMaybe<CurrentAptosNamesBoolExp>;\n  aptos_names_to_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  coin_amount?: InputMaybe<NumericComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasBoolExp>;\n  event_account_address?: InputMaybe<StringComparisonExp>;\n  event_creation_number?: InputMaybe<BigintComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_sequence_number?: InputMaybe<BigintComparisonExp>;\n  from_address?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  to_address?: InputMaybe<StringComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  transfer_type?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type TokenActivitiesMaxFields = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transfer_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"token_activities\" */\nexport type TokenActivitiesMaxOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  transfer_type?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type TokenActivitiesMinFields = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transfer_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"token_activities\" */\nexport type TokenActivitiesMinOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  transfer_type?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"token_activities\". */\nexport type TokenActivitiesOrderBy = {\n  aptos_names_owner_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  aptos_names_to_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  coin_amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasOrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  transfer_type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"token_activities\" */\nexport enum TokenActivitiesSelectColumn {\n  /** column name */\n  CoinAmount = \"coin_amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventCreationNumber = \"event_creation_number\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventSequenceNumber = \"event_sequence_number\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  TransferType = \"transfer_type\",\n}\n\n/** aggregate stddev on columns */\nexport type TokenActivitiesStddevFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"token_activities\" */\nexport type TokenActivitiesStddevOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenActivitiesStddevPopFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"token_activities\" */\nexport type TokenActivitiesStddevPopOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenActivitiesStddevSampFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"token_activities\" */\nexport type TokenActivitiesStddevSampOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"token_activities\" */\nexport type TokenActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenActivitiesStreamCursorValueInput = {\n  coin_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transfer_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenActivitiesSumFields = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"token_activities\" */\nexport type TokenActivitiesSumOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2 = {\n  after_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An array relationship */\n  aptos_names_from: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  aptos_names_from_aggregate: CurrentAptosNamesAggregate;\n  /** An array relationship */\n  aptos_names_to: Array<CurrentAptosNames>;\n  /** An aggregate relationship */\n  aptos_names_to_aggregate: CurrentAptosNamesAggregate;\n  before_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address: Scalars[\"String\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  property_version_v1: Scalars[\"numeric\"][\"output\"];\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2AptosNamesFromArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2AptosNamesFromAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2AptosNamesToArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2AptosNamesToAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAptosNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAptosNamesOrderBy>>;\n  where?: InputMaybe<CurrentAptosNamesBoolExp>;\n};\n\n/** aggregated selection of \"token_activities_v2\" */\nexport type TokenActivitiesV2Aggregate = {\n  aggregate?: Maybe<TokenActivitiesV2AggregateFields>;\n  nodes: Array<TokenActivitiesV2>;\n};\n\nexport type TokenActivitiesV2AggregateBoolExp = {\n  bool_and?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolOr>;\n  count?: InputMaybe<TokenActivitiesV2AggregateBoolExpCount>;\n};\n\nexport type TokenActivitiesV2AggregateBoolExpBoolAnd = {\n  arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type TokenActivitiesV2AggregateBoolExpBoolOr = {\n  arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type TokenActivitiesV2AggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesV2BoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"token_activities_v2\" */\nexport type TokenActivitiesV2AggregateFields = {\n  avg?: Maybe<TokenActivitiesV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenActivitiesV2MaxFields>;\n  min?: Maybe<TokenActivitiesV2MinFields>;\n  stddev?: Maybe<TokenActivitiesV2StddevFields>;\n  stddev_pop?: Maybe<TokenActivitiesV2StddevPopFields>;\n  stddev_samp?: Maybe<TokenActivitiesV2StddevSampFields>;\n  sum?: Maybe<TokenActivitiesV2SumFields>;\n  var_pop?: Maybe<TokenActivitiesV2VarPopFields>;\n  var_samp?: Maybe<TokenActivitiesV2VarSampFields>;\n  variance?: Maybe<TokenActivitiesV2VarianceFields>;\n};\n\n/** aggregate fields of \"token_activities_v2\" */\nexport type TokenActivitiesV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"token_activities_v2\" */\nexport type TokenActivitiesV2AggregateOrderBy = {\n  avg?: InputMaybe<TokenActivitiesV2AvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<TokenActivitiesV2MaxOrderBy>;\n  min?: InputMaybe<TokenActivitiesV2MinOrderBy>;\n  stddev?: InputMaybe<TokenActivitiesV2StddevOrderBy>;\n  stddev_pop?: InputMaybe<TokenActivitiesV2StddevPopOrderBy>;\n  stddev_samp?: InputMaybe<TokenActivitiesV2StddevSampOrderBy>;\n  sum?: InputMaybe<TokenActivitiesV2SumOrderBy>;\n  var_pop?: InputMaybe<TokenActivitiesV2VarPopOrderBy>;\n  var_samp?: InputMaybe<TokenActivitiesV2VarSampOrderBy>;\n  variance?: InputMaybe<TokenActivitiesV2VarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type TokenActivitiesV2AvgFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2AvgOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"token_activities_v2\". All fields are combined with a logical 'AND'. */\nexport type TokenActivitiesV2BoolExp = {\n  _and?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;\n  _not?: InputMaybe<TokenActivitiesV2BoolExp>;\n  _or?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;\n  after_value?: InputMaybe<StringComparisonExp>;\n  aptos_names_from?: InputMaybe<CurrentAptosNamesBoolExp>;\n  aptos_names_from_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  aptos_names_to?: InputMaybe<CurrentAptosNamesBoolExp>;\n  aptos_names_to_aggregate?: InputMaybe<CurrentAptosNamesAggregateBoolExp>;\n  before_value?: InputMaybe<StringComparisonExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_account_address?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  from_address?: InputMaybe<StringComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  property_version_v1?: InputMaybe<NumericComparisonExp>;\n  to_address?: InputMaybe<StringComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type TokenActivitiesV2MaxFields = {\n  after_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  before_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2MaxOrderBy = {\n  after_value?: InputMaybe<OrderBy>;\n  before_value?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type TokenActivitiesV2MinFields = {\n  after_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  before_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2MinOrderBy = {\n  after_value?: InputMaybe<OrderBy>;\n  before_value?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"token_activities_v2\". */\nexport type TokenActivitiesV2OrderBy = {\n  after_value?: InputMaybe<OrderBy>;\n  aptos_names_from_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  aptos_names_to_aggregate?: InputMaybe<CurrentAptosNamesAggregateOrderBy>;\n  before_value?: InputMaybe<OrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2SelectColumn {\n  /** column name */\n  AfterValue = \"after_value\",\n  /** column name */\n  BeforeValue = \"before_value\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** select \"token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n}\n\n/** select \"token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n}\n\n/** aggregate stddev on columns */\nexport type TokenActivitiesV2StddevFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2StddevOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenActivitiesV2StddevPopFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2StddevPopOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenActivitiesV2StddevSampFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2StddevSampOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"token_activities_v2\" */\nexport type TokenActivitiesV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenActivitiesV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenActivitiesV2StreamCursorValueInput = {\n  after_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  before_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenActivitiesV2SumFields = {\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2SumOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenActivitiesV2VarPopFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2VarPopOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenActivitiesV2VarSampFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2VarSampOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type TokenActivitiesV2VarianceFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2VarianceOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenActivitiesVarPopFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"token_activities\" */\nexport type TokenActivitiesVarPopOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenActivitiesVarSampFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"token_activities\" */\nexport type TokenActivitiesVarSampOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type TokenActivitiesVarianceFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"token_activities\" */\nexport type TokenActivitiesVarianceOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"token_datas\" */\nexport type TokenDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  default_properties: Scalars[\"jsonb\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  largest_property_version: Scalars[\"numeric\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  payee_address: Scalars[\"String\"][\"output\"];\n  properties_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_points_denominator: Scalars[\"numeric\"][\"output\"];\n  royalty_points_numerator: Scalars[\"numeric\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** columns and relationships of \"token_datas\" */\nexport type TokenDatasDefaultPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"token_datas\". All fields are combined with a logical 'AND'. */\nexport type TokenDatasBoolExp = {\n  _and?: InputMaybe<Array<TokenDatasBoolExp>>;\n  _not?: InputMaybe<TokenDatasBoolExp>;\n  _or?: InputMaybe<Array<TokenDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  default_properties?: InputMaybe<JsonbComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  largest_property_version?: InputMaybe<NumericComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  payee_address?: InputMaybe<StringComparisonExp>;\n  properties_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;\n  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"token_datas\". */\nexport type TokenDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  default_properties?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  largest_property_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  payee_address?: InputMaybe<OrderBy>;\n  properties_mutable?: InputMaybe<OrderBy>;\n  royalty_mutable?: InputMaybe<OrderBy>;\n  royalty_points_denominator?: InputMaybe<OrderBy>;\n  royalty_points_numerator?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"token_datas\" */\nexport enum TokenDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DefaultProperties = \"default_properties\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  LargestPropertyVersion = \"largest_property_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  PropertiesMutable = \"properties_mutable\",\n  /** column name */\n  RoyaltyMutable = \"royalty_mutable\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** Streaming cursor of the table \"token_datas\" */\nexport type TokenDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** columns and relationships of \"token_ownerships\" */\nexport type TokenOwnerships = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"token_ownerships\". All fields are combined with a logical 'AND'. */\nexport type TokenOwnershipsBoolExp = {\n  _and?: InputMaybe<Array<TokenOwnershipsBoolExp>>;\n  _not?: InputMaybe<TokenOwnershipsBoolExp>;\n  _or?: InputMaybe<Array<TokenOwnershipsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  table_type?: InputMaybe<StringComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"token_ownerships\". */\nexport type TokenOwnershipsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  table_type?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"token_ownerships\" */\nexport enum TokenOwnershipsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TableType = \"table_type\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** Streaming cursor of the table \"token_ownerships\" */\nexport type TokenOwnershipsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenOwnershipsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenOwnershipsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"tokens\" */\nexport type Tokens = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"tokens\" */\nexport type TokensTokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"tokens\". All fields are combined with a logical 'AND'. */\nexport type TokensBoolExp = {\n  _and?: InputMaybe<Array<TokensBoolExp>>;\n  _not?: InputMaybe<TokensBoolExp>;\n  _or?: InputMaybe<Array<TokensBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"tokens\". */\nexport type TokensOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"tokens\" */\nexport enum TokensSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** Streaming cursor of the table \"tokens\" */\nexport type TokensStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokensStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokensStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** columns and relationships of \"user_transactions\" */\nexport type UserTransactions = {\n  block_height: Scalars[\"bigint\"][\"output\"];\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  epoch: Scalars[\"bigint\"][\"output\"];\n  expiration_timestamp_secs: Scalars[\"timestamp\"][\"output\"];\n  gas_unit_price: Scalars[\"numeric\"][\"output\"];\n  max_gas_amount: Scalars[\"numeric\"][\"output\"];\n  parent_signature_type: Scalars[\"String\"][\"output\"];\n  sender: Scalars[\"String\"][\"output\"];\n  sequence_number: Scalars[\"bigint\"][\"output\"];\n  timestamp: Scalars[\"timestamp\"][\"output\"];\n  version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** Boolean expression to filter rows from the table \"user_transactions\". All fields are combined with a logical 'AND'. */\nexport type UserTransactionsBoolExp = {\n  _and?: InputMaybe<Array<UserTransactionsBoolExp>>;\n  _not?: InputMaybe<UserTransactionsBoolExp>;\n  _or?: InputMaybe<Array<UserTransactionsBoolExp>>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  epoch?: InputMaybe<BigintComparisonExp>;\n  expiration_timestamp_secs?: InputMaybe<TimestampComparisonExp>;\n  gas_unit_price?: InputMaybe<NumericComparisonExp>;\n  max_gas_amount?: InputMaybe<NumericComparisonExp>;\n  parent_signature_type?: InputMaybe<StringComparisonExp>;\n  sender?: InputMaybe<StringComparisonExp>;\n  sequence_number?: InputMaybe<BigintComparisonExp>;\n  timestamp?: InputMaybe<TimestampComparisonExp>;\n  version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** Ordering options when selecting data from \"user_transactions\". */\nexport type UserTransactionsOrderBy = {\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  epoch?: InputMaybe<OrderBy>;\n  expiration_timestamp_secs?: InputMaybe<OrderBy>;\n  gas_unit_price?: InputMaybe<OrderBy>;\n  max_gas_amount?: InputMaybe<OrderBy>;\n  parent_signature_type?: InputMaybe<OrderBy>;\n  sender?: InputMaybe<OrderBy>;\n  sequence_number?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"user_transactions\" */\nexport enum UserTransactionsSelectColumn {\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  Epoch = \"epoch\",\n  /** column name */\n  ExpirationTimestampSecs = \"expiration_timestamp_secs\",\n  /** column name */\n  GasUnitPrice = \"gas_unit_price\",\n  /** column name */\n  MaxGasAmount = \"max_gas_amount\",\n  /** column name */\n  ParentSignatureType = \"parent_signature_type\",\n  /** column name */\n  Sender = \"sender\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  Timestamp = \"timestamp\",\n  /** column name */\n  Version = \"version\",\n}\n\n/** Streaming cursor of the table \"user_transactions\" */\nexport type UserTransactionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: UserTransactionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type UserTransactionsStreamCursorValueInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  expiration_timestamp_secs?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  gas_unit_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  max_gas_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  parent_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sender?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n"],"mappings":"iCA2PO,IAAKA,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,mBAAqB,sBAJXA,OAAA,IAqFAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,mBAEjBA,EAAA,oBAAsB,wBANZA,OAAA,IAkLAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,mBAAqB,sBAJXA,OAAA,IAkNAC,OAEVA,EAAA,QAAU,UAEVA,EAAA,mBAAqB,sBAJXA,OAAA,IA0HAC,OAEVA,EAAA,YAAc,eAEdA,EAAA,MAAQ,QAERA,EAAA,sBAAwB,0BAExBA,EAAA,GAAK,KAELA,EAAA,yBAA2B,8BAE3BA,EAAA,SAAW,WAEXA,EAAA,MAAQ,QAERA,EAAA,UAAY,YAEZA,EAAA,QAAU,UAlBAA,OAAA,IAmSAC,OAEVA,EAAA,aAAe,gBAEfA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,mBAAqB,wBAErBA,EAAA,oBAAsB,wBAEtBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,oBAAsB,wBAEtBA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBA9BXA,OAAA,IAkCAC,OAEVA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAJbA,OAAA,IAQAC,OAEVA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAJbA,OAAA,IA8NAC,OAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,aAAe,gBAEfA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAZXA,OAAA,IA+EAC,OAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,SAAW,WAEXA,EAAA,KAAO,OAEPA,EAAA,4BAA8B,iCAE9BA,EAAA,yBAA2B,8BAE3BA,EAAA,OAAS,SAETA,EAAA,4BAA8B,gCAE9BA,EAAA,0BAA4B,8BApBlBA,OAAA,IA+EAC,OAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,OAAS,SAETA,EAAA,iBAAmB,oBAEnBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAZXA,OAAA,IAwFAC,OAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cA1BHA,OAAA,IAoHAC,OAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAdFA,OAAA,IA4EAC,OAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAhBNA,OAAA,IA+OAC,OAEVA,EAAA,OAAS,SAETA,EAAA,0BAA4B,8BAE5BA,EAAA,iBAAmB,qBAEnBA,EAAA,oBAAsB,uBAEtBA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,0BAA4B,8BAE5BA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBA1BNA,OAAA,IA8BAC,OAEVA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAJFA,OAAA,IAQAC,OAEVA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAJFA,OAAA,IA0JAC,OAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAZLA,OAAA,IAwFAC,OAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,WAAa,cA1BHA,OAAA,IA2JAC,OAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,mBAhBPA,OAAA,IA+IAC,OAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,YAAc,cAEdA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAEhBA,EAAA,cAAgB,kBAEhBA,EAAA,IAAM,MA5BIA,OAAA,IA8FAC,OAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,oBAAsB,wBAEtBA,EAAA,uBAAyB,2BAEzBA,EAAA,6BAA+B,iCAE/BA,EAAA,mBAAqB,uBAErBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAdJA,OAAA,IAyEAC,OAEVA,EAAA,sBAAwB,0BAExBA,EAAA,iBAAmB,oBAEnBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,YAAc,eAEdA,EAAA,MAAQ,QAdEA,OAAA,IAiFAC,OAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,sBAEpBA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,YAAc,eAdJA,OAAA,IA0IAC,OAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAlBNA,OAAA,IAyHAC,OAEVA,EAAA,qBAAuB,yBAEvBA,EAAA,UAAY,aAEZA,EAAA,oBAAsB,yBAEtBA,EAAA,uBAAyB,2BAEzBA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAdLA,OAAA,IAyFAC,OAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,gBAAkB,mBAElBA,EAAA,mBAAqB,uBAErBA,EAAA,aAAe,gBARLA,OAAA,IA0EAC,OAEVA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,IAAM,MAENA,EAAA,QAAU,WAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,eAdJA,OAAA,IA4HAC,OAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,kBAAoB,qBAEpBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,uBAAyB,2BAEzBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,OAAS,SAETA,EAAA,gBAAkB,qBAElBA,EAAA,WAAa,cA1CHA,OAAA,IAkLAC,OAEVA,EAAA,aAAe,gBAEfA,EAAA,SAAW,WAEXA,EAAA,YAAc,cAEdA,EAAA,aAAe,iBAEfA,EAAA,yBAA2B,8BAE3BA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,mBAElBA,EAAA,cAAgB,iBAEhBA,EAAA,SAAW,YA5BDA,OAAA,IA6PAC,OAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,qBAElBA,EAAA,gBAAkB,mBAxBRA,OAAA,IA2UAC,OAEVA,EAAA,OAAS,SAETA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,wBAA0B,6BAE1BA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,yBAA2B,8BAE3BA,EAAA,cAAgB,iBA1BNA,OAAA,IA8BAC,OAEVA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,wBAA0B,6BANhBA,OAAA,IAUAC,OAEVA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,wBAA0B,6BANhBA,OAAA,IA4PAC,OAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,gBAAkB,qBA5BRA,OAAA,IA0DAC,OAEVA,EAAA,IAAM,MAENA,EAAA,KAAO,OAJGA,OAAA,IAmFAC,QAEVA,EAAA,OAAS,SAETA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAZXA,QAAA,IAgLAC,QAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,oBAAsB,wBAEtBA,EAAA,6BAA+B,iCAE/BA,EAAA,mBAAqB,uBAErBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAdXA,QAAA,IAsHAC,QAEVA,EAAA,wBAA0B,4BAE1BA,EAAA,mBAAqB,uBAJXA,QAAA,IAkFAC,QAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,YAAc,eAJJA,QAAA,IAqEAC,QAEVA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAlBGA,QAAA,IAiMAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,wBAErBA,EAAA,SAAW,YAEXA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,oBAAsB,wBAEtBA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAhCGA,QAAA,IAkLAC,QAEVA,EAAA,UAAY,aAEZA,EAAA,eAAiB,kBAEjBA,EAAA,SAAW,WAEXA,EAAA,QAAU,WAEVA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,8BAAgC,oCAEhCA,EAAA,2BAA6B,iCAE7BA,EAAA,OAAS,SAETA,EAAA,cAAgB,iBAxBNA,QAAA,IAyEAC,QAEVA,EAAA,GAAK,KAELA,EAAA,YAAc,gBAJJA,QAAA,IAoEAC,QAEVA,EAAA,QAAU,WAFAA,QAAA,IAoFAC,QAEVA,EAAA,QAAU,UAEVA,EAAA,mBAAqB,sBAJXA,QAAA,IAqIAC,QAEVA,EAAA,cAAgB,mBAEhBA,EAAA,SAAW,YAEXA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,gBAAkB,oBAElBA,EAAA,cAAgB,iBAEhBA,EAAA,mBAAqB,wBAErBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,YAAc,cAEdA,EAAA,OAAS,SAETA,EAAA,iBAAmB,qBAEnBA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,cAAgB,iBAtCNA,QAAA,IAyIAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,SAAW,YAEXA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,gBAAkB,mBAElBA,EAAA,mBAAqB,wBAErBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,cAEdA,EAAA,qBAAuB,yBAEvBA,EAAA,cAAgB,iBA9BNA,QAAA,IAmMAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,mBAAqB,wBAErBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,YAAc,cAEdA,EAAA,MAAQ,QAERA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,cAAgB,iBA9BNA,QAAA,IAiLAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,SAAW,YAEXA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,mBAAqB,wBAErBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,cAEdA,EAAA,QAAU,WAEVA,EAAA,MAAQ,QAERA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,cAAgB,iBAhCNA,QAAA,IAkJAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,SAAW,YAEXA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,gBAAkB,mBAElBA,EAAA,eAAiB,kBAEjBA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,cAAgB,kBAEhBA,EAAA,YAAc,cAEdA,EAAA,iBAAmB,sBAEnBA,EAAA,MAAQ,QAERA,EAAA,gBAAkB,mBAElBA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBA1CXA,QAAA,IAyHAC,QAEVA,EAAA,6BAA+B,kCAE/BA,EAAA,SAAW,YAEXA,EAAA,gBAAkB,oBAElBA,EAAA,YAAc,gBAEdA,EAAA,WAAa,eAEbA,EAAA,yBAA2B,8BAE3BA,EAAA,qBAAuB,0BAEvBA,EAAA,gBAAkB,oBAElBA,EAAA,YAAc,gBAlBJA,QAAA,IAgEAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,YAAc,eAJJA,QAAA,IAmCAC,QAEVA,EAAA,IAAM,MAENA,EAAA,cAAgB,kBAEhBA,EAAA,aAAe,iBAEfA,EAAA,KAAO,OAEPA,EAAA,eAAiB,mBAEjBA,EAAA,cAAgB,kBAZNA,QAAA,IA2CAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,yBAA2B,6BAE3BA,EAAA,YAAc,eAEdA,EAAA,UAAY,YARFA,QAAA,IAsHAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,WAAa,cAEbA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,uBAErBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,gBAdLA,QAAA,IAgsCAC,QAEVA,EAAA,gBAAkB,oBAElBA,EAAA,gBAAkB,oBAElBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,iBAAmB,qBAEnBA,EAAA,UAAY,YAEZA,EAAA,OAAS,SAETA,EAAA,UAAY,YAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAtBGA,QAAA,IAylDAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,IAAM,MAENA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAZZA,QAAA,IA0DAC,QAEVA,EAAA,OAAS,SAETA,EAAA,QAAU,WAEVA,EAAA,UAAY,aANFA,QAAA,IAiVAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,oBAAsB,wBAEtBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,oBAAsB,wBAEtBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,gBApCLA,QAAA,IA6aAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,aAAe,iBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OA9BGA,QAAA,IAkCAC,QAEVA,EAAA,aAAe,iBAFLA,QAAA,IAMAC,QAEVA,EAAA,aAAe,iBAFLA,QAAA,IAsSAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,kBAAoB,qBAEpBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,OAAS,SAETA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cA1CHA,QAAA,IAkIAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAxBXA,QAAA,IAmGAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,gBAAkB,qBAElBA,EAAA,gBAAkB,mBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAlBXA,QAAA,IA2FAC,QAEVA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,MAAQ,QAERA,EAAA,wBAA0B,4BAE1BA,EAAA,aAAe,iBAEfA,EAAA,aAAe,iBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,OAAS,SAETA,EAAA,eAAiB,kBAEjBA,EAAA,UAAY,YAEZA,EAAA,QAAU,UAtBAA,QAAA","names":["AccountTransactionsSelectColumn","AddressEventsSummarySelectColumn","AddressVersionFromEventsSelectColumn","AddressVersionFromMoveResourcesSelectColumn","BlockMetadataTransactionsSelectColumn","CoinActivitiesSelectColumn","CoinActivitiesSelectColumnCoinActivitiesAggregateBoolExpBoolAndArgumentsColumns","CoinActivitiesSelectColumnCoinActivitiesAggregateBoolExpBoolOrArgumentsColumns","CoinBalancesSelectColumn","CoinInfosSelectColumn","CoinSupplySelectColumn","CollectionDatasSelectColumn","CurrentAnsLookupSelectColumn","CurrentAnsLookupV2SelectColumn","CurrentAptosNamesSelectColumn","CurrentAptosNamesSelectColumnCurrentAptosNamesAggregateBoolExpBoolAndArgumentsColumns","CurrentAptosNamesSelectColumnCurrentAptosNamesAggregateBoolExpBoolOrArgumentsColumns","CurrentCoinBalancesSelectColumn","CurrentCollectionDatasSelectColumn","CurrentCollectionOwnershipV2ViewSelectColumn","CurrentCollectionsV2SelectColumn","CurrentDelegatedStakingPoolBalancesSelectColumn","CurrentDelegatedVoterSelectColumn","CurrentDelegatorBalancesSelectColumn","CurrentFungibleAssetBalancesSelectColumn","CurrentObjectsSelectColumn","CurrentStakingPoolVoterSelectColumn","CurrentTableItemsSelectColumn","CurrentTokenDatasSelectColumn","CurrentTokenDatasV2SelectColumn","CurrentTokenOwnershipsSelectColumn","CurrentTokenOwnershipsV2SelectColumn","CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns","CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns","CurrentTokenPendingClaimsSelectColumn","CursorOrdering","DelegatedStakingActivitiesSelectColumn","DelegatedStakingPoolBalancesSelectColumn","DelegatedStakingPoolsSelectColumn","DelegatorDistinctPoolSelectColumn","EventsSelectColumn","FungibleAssetActivitiesSelectColumn","FungibleAssetMetadataSelectColumn","IndexerStatusSelectColumn","LedgerInfosSelectColumn","MoveResourcesSelectColumn","NftMarketplaceV2CurrentNftMarketplaceAuctionsSelectColumn","NftMarketplaceV2CurrentNftMarketplaceCollectionOffersSelectColumn","NftMarketplaceV2CurrentNftMarketplaceListingsSelectColumn","NftMarketplaceV2CurrentNftMarketplaceTokenOffersSelectColumn","NftMarketplaceV2NftMarketplaceActivitiesSelectColumn","NftMetadataCrawlerParsedAssetUrisSelectColumn","NumActiveDelegatorPerPoolSelectColumn","OrderBy","ProcessorStatusSelectColumn","ProposalVotesSelectColumn","SignaturesSelectColumn","TableItemsSelectColumn","TableMetadatasSelectColumn","TokenActivitiesSelectColumn","TokenActivitiesV2SelectColumn","TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns","TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns","TokenDatasSelectColumn","TokenOwnershipsSelectColumn","TokensSelectColumn","UserTransactionsSelectColumn"]}